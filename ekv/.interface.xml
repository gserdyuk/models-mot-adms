<!--
  File automatically created
  Command used:
  # release: 2.3.0 Mar 16 2010-14:12:43
  admsXml \
   -e ../admst/ngspiceVersion.xml \
   -e ../admst/ngspiceMODULEitf.h.xml \
   -e ../admst/ngspiceMODULEinit.c.xml \
   -e ../admst/ngspiceMODULEinit.h.xml \
   -e ../admst/ngspiceMODULEext.h.xml \
   -e ../admst/ngspiceMODULEdefs.h.xml \
   -e ../admst/ngspiceMODULEask.c.xml \
   -e ../admst/ngspiceMODULEmask.c.xml \
   -e ../admst/ngspiceMODULEpar.c.xml \
   -e ../admst/ngspiceMODULEmpar.c.xml \
   -e ../admst/ngspiceMODULEload.c.xml \
   -e ../admst/ngspiceMODULEacld.c.xml \
   -e ../admst/ngspiceMODULEpzld.c.xml \
   -e ../admst/ngspiceMODULEtemp.c.xml \
   -e ../admst/ngspiceMODULEtrunc.c.xml \
   -e ../admst/ngspiceMODULEsetup.c.xml \
   -e ../admst/ngspiceMODULEdel.c.xml \
   -e ../admst/ngspiceMODULEmdel.c.xml \
   -e ../admst/ngspiceMODULEdest.c.xml \
   -e ../admst/ngspiceMODULEnoise.c.xml \
   -e ../admst/ngspiceMODULEguesstopology.c.xml \
   -e ../admst/ngspiceMODULE.hxx.xml \
   -e ../admst/ngspiceMODULE.c.xml
-->


<?escript name="../admst/ngspiceVersion.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- RCS Info -->
<!--
  $Id: ngspiceVersion.xml,v 1.20 2007/07/05 10:20:48 r29173 Exp $
-->
<!--
  $Log: ngspiceVersion.xml,v $
  Revision 1.20  2007/07/05 10:20:48  r29173
  added declaration of noise variables

  Revision 1.19  2007/05/13 09:55:14  pnenzi

  Updated the code for ekv model.

  Revision 1.18  2007/05/11 07:19:58  r29173
  added support to 'div' builtin function

  Revision 1.17  2007/05/02 14:56:49  r29173
  changed required adms version to 2.2.6

  Revision 1.16  2007/04/30 13:10:35  r29173
  improved 'guesstopology'
  fixed implementation of macro 'noise'
  when building 'load' traverse block 'noise'

  Revision 1.15  2007/04/26 13:04:34  r29173
  added cases initializeModel, initiliazeInstance (block name used by psp102)

  Revision 1.14  2007/04/24 12:28:15  r29173
  add case 'blockvariable'

  Revision 1.13  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.12  2006/03/06 12:55:02  r29173
  added support to 'analog functions'

  Revision 1.11  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.10  2006/03/02 09:04:38  r29173
  started handling of adms elements 'case' and 'nilled'

  Revision 1.9  2006/02/21 20:06:05  dwarning
  Set pnp default to 0.

  Revision 1.8  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.7  2006/02/10 06:59:56  pnenzi

  Added section for r and c elements (Laurent)

  Revision 1.6  2006/02/09 11:25:24  pnenzi

  Latest update from Laurent and Dietmar: (empty instances)

  Revision 1.3  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.2  2006/02/02 14:26:50  pnenzi

  Removed nmos and pmos from list of parameters. (Laurent)

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->
<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.6" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match=":new:jacobian">
  <admst:value-of select="module"/>
  <admst:new datatype="jacobian" arguments="%p,%p,%p">
    <admst:push into="module/jacobian" select="." onduplicate="ignore"/>
    <admst:value-of select="column"/>
    <admst:if test="[row='%p']">
      <admst:value-to select="diagonal" value="yes"/>
    </admst:if>
    <admst:if test="../../..[dynamic='yes']">
      <admst:value-to select="dynamic" value="yes"/>
    </admst:if>
    <admst:if test="../../..[dynamic='no']">
      <admst:value-to select="static" value="yes"/>
    </admst:if>
  </admst:new>
</admst:template>

<admst:template match="expression:stringify:noprobe">
  <admst:apply-templates select="tree" match="subexpression:differentiate"/>
  <admst:value-of select="/simulator/tmp"/>
</admst:template>
<admst:template match="subexpression:stringify:noprobe">
  <admst:apply-templates select="." match="subexpression:differentiate"/>
  <admst:value-of select="/simulator/tmp"/>
</admst:template>
<admst:template match="subexpression:differentiate">
  <admst:value-of select="./adms/datatypename"/>
  <admst:apply-templates select="." match="%s"/>
  <admst:if test="/simulator/probe">
    <admst:choose>
      <admst:when test="adms[datatypename='probe']">
        <admst:choose>
          <admst:when test="[.=/simulator/probe]">
            <admst:value-to select="/simulator/ddx" value="1.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="adms[datatypename='variable']">
        <admst:value-of select="probe"/>
        <admst:if-not-inside select="/simulator/probe" list="%p">
          <admst:value-to select="/simulator/ddx" value="0.0"/>
        </admst:if-not-inside>
        <admst:value-of select="probe"/>
        <admst:if-inside select="/simulator/probe" list="%p">
          <admst:choose>
            <admst:when test="[insource='yes']">
              <admst:value-of select="/simulator/probe/branch/nnode/name"/>
              <admst:value-of select="/simulator/probe/branch/pnode/name"/>
              <admst:value-of select="/simulator/probe/nature/access"/>
              <admst:value-of select="name"/>
              <admst:value-to select="/simulator/ddx" value="%s_%s%s_%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="/simulator/ddx" value="0.0"/>
            </admst:otherwise>
          </admst:choose>
        </admst:if-inside>
      </admst:when>
      <admst:when test="adms[ datatypename='number' or datatypename='variable']">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- mapply_unary-->
<admst:template match="mapply_unary">
  <admst:choose>
    <admst:when test="[name='plus']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="(+%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='minus']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="(-%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='not']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="(!%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='bw_not']">
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="(~%s)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/>
      <admst:error format="%s: function not handled\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="/simulator/probe">
    <admst:choose>
      <admst:when test="/simulator[tmp='0.0']">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:when>
      <admst:otherwise>
        <admst:choose>
          <admst:when test="[name='plus']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(+%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='minus']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(-%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='not']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(!%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='bw_not']">
            <admst:choose>
              <admst:when test="/simulator[ddx!='0.0']">
                <admst:value-of select="/simulator/ddx"/>
                <admst:value-to select="/simulator/ddx" value="(~%s)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
        </admst:choose>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- mapply_binary !-->
<admst:template match="mapply_binary">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s^~%s)"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s~^%s)"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s^%s)"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s|%s)"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&amp;%s)"/>
    </admst:when>
    <admst:when test="[name='multmod']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s%%%s)"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s||%s)"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&amp;&amp;%s)"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s==%s)"/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s!=%s)"/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&lt;%s)"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&lt;=%s)"/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&gt;%s)"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&gt;=%s)"/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&gt;&gt;%s)"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
      <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
      <admst:value-to select="/simulator/tmp" value="(%s&lt;&lt;%s)"/>
    </admst:when>
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg1/math[value=0.0]">
          <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="(+%s)"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
            <admst:variable name="dx" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
          <admst:variable name="y" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:value-to select="/simulator/tmp" value="($x+$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg1/math[value=0.0]">
          <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="(-%s)"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
            <admst:variable name="dx" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:value-to select="/simulator/tmp" value="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
          <admst:variable name="y" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:value-to select="/simulator/tmp" value="($x-$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:variable name="x" select="0.0"/>
      <admst:variable name="y" select="0.0"/>
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:value-to select="/simulator/tmp" value="1.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:variable name="y" select="%s"/>
          <admst:value-to select="/simulator/tmp" value="($x*$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:variable name="x" select="0.0"/>
      <admst:variable name="y" select="0.0"/>
      <admst:choose>
        <admst:when test="arg1/math[value=0.0]">
          <admst:value-to select="/simulator/tmp" value="0.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:value-to select="/simulator/tmp" value="1.0"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dx" select="0.0"/>
            <admst:variable name="dy" select="0.0"/>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
          <admst:variable name="x" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dx" select="%s"/>
          </admst:if>
          <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
          <admst:variable name="y" select="%s"/>
          <admst:if test="/simulator/probe">
            <admst:value-of select="/simulator/ddx"/>
            <admst:variable name="dy" select="%s"/>
          </admst:if>
          <admst:value-to select="/simulator/tmp" value="($x/$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/>
      <admst:error format="%s: function not handled\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:if test="/simulator/probe">
    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="(+$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="$dx"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="($dx+$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="(-$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="$dx"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="($dx-$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0' and $dy='1.0']">
            <admst:value-to select="/simulator/ddx" value="($x)"/>
          </admst:when>
          <admst:when test="[$dx='1.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="($y)"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="($x*$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="$dx*$y"/>
          </admst:when>
          <admst:when test="[$dx='1.0' and $dy='1.0']">
            <admst:value-to select="/simulator/ddx" value="($x+$y)"/>
          </admst:when>
          <admst:when test="[$dx='1.0']">
            <admst:value-to select="/simulator/ddx" value="($y+($dy*$x))"/>
          </admst:when>
          <admst:when test="[$dy='1.0']">
            <admst:value-to select="/simulator/ddx" value="($dx*$y)+$x"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:value-to select="/simulator/ddx" value="$dy"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:value-to select="/simulator/ddx" value="$dx"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="(($dx*$y)+($x*$dy))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(-1/($y*$y))"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="(-$dy/($y*$y))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:choose>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(-$x/($y*$y))"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="(-($x*$dy)/($y*$y))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$dx='1.0']">
            <admst:choose>
              <admst:when test="[$dy='0.0']">
                <admst:value-to select="/simulator/ddx" value="(1/$y)"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(($y-$x)/($y*$y))"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="(($y-($x*$dy))/($y*$y))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:value-to select="/simulator/ddx" value="$dx"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:value-to select="/simulator/ddx" value="$dx/$y"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:value-to select="/simulator/ddx" value="(($dx*$y)-$x)/($y*$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="/simulator/ddx" value="($dx*$y-$x*$dy)/($y*$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:value-to select="/simulator/ddx" value=""/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>

</admst:template>

<!-- mapply_ternary-->
<admst:template match="mapply_ternary">
  <admst:apply-templates select="arg3" match="subexpression:stringify:noprobe"/>
  <admst:value-of select="/simulator/ddx"/>
  <admst:variable name="dz" select="%s"/>
  <admst:apply-templates select="arg2" match="subexpression:stringify:noprobe"/>
  <admst:value-of select="/simulator/ddx"/>
  <admst:variable name="dy" select="%s"/>
  <admst:apply-templates select="arg1" match="subexpression:stringify:noprobe"/>
  <admst:variable name="x" select="%s"/>
  <admst:value-to select="/simulator/tmp" value="($x?%s:%s)"/>
  <admst:if test="/simulator/probe">
    <admst:value-to select="/simulator/ddx" value="($x?$dy:$dz)"/>
  </admst:if>
</admst:template>

<!-- functions-->
<admst:template match="function:assert:noarg">
  <admst:if test="[not(nilled(arguments))]">
    <admst:value-of select="name"/>
    <admst:error format="%s: should not have arguments\n"/>
  </admst:if>
</admst:template>
<admst:template match="function:assert:onearg">
  <admst:if test="arguments[not(count(.)=1)]">
    <admst:value-of select="name"/>
    <admst:error format="%s: should have one argument exactly\n"/>
  </admst:if>
</admst:template>

<!-- expression//function: mapping verilog-name == C-name of function -->
<admst:template match="function:getname">
  <admst:choose>
    <admst:when test="[name='abs']"><admst:value-of select="'fabs'"/></admst:when>
    <admst:when test="[name='log']"><admst:value-of select="'log10'"/></admst:when>
    <admst:when test="[name='ln']"><admst:value-of select="'logE'"/></admst:when>
    <admst:when test="[name='limexp']"><admst:value-of select="'limexp'"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:value-of select="'limexp'"/></admst:when>
    <admst:when test="[name='\$model']"><admst:value-of select="'_modelname'"/></admst:when>
    <admst:when test="[name='\$instance']"><admst:value-of select="'_instancename'"/></admst:when>
    <admst:when test="[name='\$temperature']"><admst:value-of select="'_circuit_temp'"/></admst:when>
    <admst:otherwise><admst:value-of select="name"/></admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="function">
  <admst:choose>
    <admst:when test="[name='ddt']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
        <admst:value-to select="/simulator/tmp" value="%s"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[name='\$given']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:if test="adms[datatypename!='variable']">
          <admst:error format="$given: argument is not a variable\n"/>
        </admst:if>
        <admst:if test="[input='no']">
          <admst:value-of select="name"/>
          <admst:error format="$given(%s): argument is not a parameter\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[parametertype='model']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="model->%s_Given"/>
          </admst:when>
          <admst:when test="[parametertype='instance']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="here->%s_Given"/>
          </admst:when>
          <admst:otherwise>
            <admst:error format="$given(%s): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$model']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$instance']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$nominal_temperature']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
       <admst:when test="arguments">
        <admst:choose>
         <admst:when test="arguments[count(.)=1]">
          <admst:apply-templates select="." match="function:assert:onearg"/>
          <admst:for-each select="arguments[position(.)=1]">
            <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
            <admst:value-to select="/simulator/tmp" value="_vt(%s)"/>
          </admst:for-each>
         </admst:when>
         <admst:otherwise>
           <admst:error format="$vt(...): too many args"/>   
         </admst:otherwise>
        </admst:choose>
       </admst:when>
       <admst:otherwise>
         <admst:apply-templates select="." match="function:assert:noarg"/>
         <admst:value-to select="/simulator/tmp" value="_vt_nom"/>   
       </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$scale']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:value-to select="/simulator/tmp" value="_scale"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$abstime']">
      <admst:apply-templates select="." match="function:assert:noarg"/>
      <admst:value-to select="/simulator/tmp" value="_abstime"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='\$options']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:if test="adms[datatypename!='string']">
          <admst:error format="$given: argument is not a string\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[value='OPTm_hier']">
            <admst:value-to select="/simulator/tmp" value="_circuit_m_hier"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-of select="value"/>
            <admst:fatal format="$options(%s): bad argument []\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='ddx' or name='\$derivate']">
      <admst:for-each select="arguments"> 
        <admst:if test="[position(.)=2]">
          <admst:if test="adms[datatypename!='probe']">
            <admst:value-of select="../name"/>
            <admst:error format="%s: second argument is not a probe\n"/>
          </admst:if>
          <admst:value-of select="branch/nnode/name"/>
          <admst:value-of select="branch/pnode/name"/>
          <admst:value-of select="nature/access"/>
        </admst:if>
      </admst:for-each>
      <admst:for-each select="arguments"> 
        <admst:if test="[position(.)=1]">
          <admst:if test="adms[datatypename!='variable']">
            <admst:value-of select="../name"/>
            <admst:error format="%s: first argument is not a variable\n"/>
          </admst:if>
          <admst:value-of select="name"/>
        </admst:if>
      </admst:for-each>
      <admst:value-to select="/simulator/tmp" value="%s_%s%s_%s"/>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='floor']">
      <admst:apply-templates select="." match="function:assert:onearg"/>
      <admst:for-each select="arguments[position(.)=1]">
        <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
        <admst:value-to select="/simulator/tmp" value="floor(%s)"/>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='ceil']">
      <admst:apply-templates select="." match="function:assert:onearg"/>
      <admst:for-each select="arguments[position(.)=1]">
        <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
        <admst:value-to select="/simulator/tmp" value="ceil(%s)"/>
      </admst:for-each>
      <admst:if test="/simulator/probe">
        <admst:value-to select="/simulator/ddx" value="0.0"/>
      </admst:if>
    </admst:when>
    <admst:when test="[name='pow' or name='hypot' or name='min' or name='max']">
      <admst:value-of select="index(./subexpression/expression/function,.)"/>
      <admst:variable name="index" select="%s"/>
      <admst:if test="/simulator/probe">
        <admst:for-each select="arguments"> 
          <admst:choose>
            <admst:when test="[position(.)=1]">
              <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dx" select="%s"/>
            </admst:when>
            <admst:when test="[position(.)=2]">
              <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
              <admst:variable name="y" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dy" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:count select="../arguments"/>
              <admst:value-of select="../name"/>
              <admst:error format="%s(...): two arguments expected - %s found(s) \n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/ddx" value="(__dFy_%s_$index*$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/ddx" value="(__dFx_%s_$index*$dx)"/>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="." match="function:getname"/>
            <admst:apply-templates select="." match="function:getname"/>
            <admst:value-to select="/simulator/ddx" value="(__dFx_%s_$index*$dx+__dFy_%s_$index*$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="__%s_$index"/>
    </admst:when>
    <admst:when test="[name='div']">
      <admst:value-of select="index(./subexpression/expression/function,.)"/>
      <admst:variable name="index" select="%s"/>
      <admst:if test="/simulator/probe">
        <admst:for-each select="arguments"> 
          <admst:choose>
            <admst:when test="[position(.)=1]">
              <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dx" select="%s"/>
            </admst:when>
            <admst:when test="[position(.)=2]">
              <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
              <admst:variable name="y" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dy" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:count select="../arguments"/>
              <admst:value-of select="../name"/>
              <admst:error format="%s(...): two arguments expected - %s found(s) \n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[$dx='0.0' and $dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="(__dFy_%(name)_$index*$dy)"/>
          </admst:when>
          <admst:when test="[$dy='0.0']">
            <admst:value-to select="/simulator/ddx" value="(__dFx_%(name)_$index*$dx)"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="/simulator/ddx" value="(__dFx_%(name)_$index*$dx+__dFy_%(name)_$index*$dy)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="__%s_$index"/>
    </admst:when>
    <admst:when test="[class='builtin']">
      <admst:value-of select="index(./subexpression/expression/function,.)"/>
      <admst:variable name="index" select="%s"/>
      <admst:if test="/simulator/probe">
        <admst:for-each select="arguments"> 
          <admst:choose>
            <admst:when test="[position(.)=1]">
              <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dx" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:count select="../arguments"/>
              <admst:value-of select="../name"/>
              <admst:error format="%s(...): one argument expected - %s found(s) \n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[$dx='0.0']">
            <admst:value-to select="/simulator/ddx" value="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="." match="function:getname"/>
            <admst:value-to select="/simulator/ddx" value="$dx*__d_%s_$index"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:value-to select="/simulator/tmp" value="__%s_$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='\$simparam']">
           <admst:apply-templates select="." match="function:simparam"/>
        </admst:when>
        <admst:when test="[name='analysis']">
           <admst:apply-templates select="." match="function:analysis"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-of select="name"/>
          <admst:variable name="function" select="%s"/>
          <admst:variable name="args" select=""/>
          <admst:for-each select="arguments">
            <admst:value-of select="position(.)"/>
            <admst:variable name="index" select="%s"/>
            <admst:if test="[not($args='')]">
              <admst:variable name="args" select="$args,"/>
            </admst:if>
            <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
            <admst:variable name="arg$index" select="%s"/>
            <admst:variable name="args" select="$args$(arg$index)"/>
          </admst:for-each>
          <admst:value-to select="/simulator/tmp" value="$function($args)"/>
          <admst:if test="/simulator/probe">
            <admst:variable name="dargs" select="$args"/>
            <admst:for-each select="arguments">
              <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
              <admst:variable name="x" select="%s"/>
              <admst:value-of select="/simulator/ddx"/>
              <admst:variable name="dargs" select="$dargs,%s"/>
            </admst:for-each>
            <admst:value-to select="/simulator/ddx" value="d_$function($dargs)"/>
          </admst:if>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="function:analysis">
  <admst:value-of select="name"/>
  <admst:variable name="function" select="%s"/>
  <admst:variable name="args" select=""/>
  <admst:for-each select="arguments">
    <admst:value-of select="position(.)"/>
    <admst:variable name="index" select="%s"/>
    <admst:if test="[not($args='')]">
      <admst:variable name="args" select="$args,"/>
    </admst:if>
    <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
    <admst:variable name="arg$index" select="%s"/>
    <admst:variable name="args" select="$args$(arg$index)"/>
  </admst:for-each>
  <admst:choose>
    <admst:when test="[$arg1='&quot;noise&quot;']">
      <admst:value-to select="/simulator/tmp" value="0.0"/>
      <admst:error format="$function($args): replaced by 0.0\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:error format="$function($args) -- not implemented in ngspice interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="function:simparam">
  <admst:value-of select="name"/>
  <admst:variable name="function" select="%s"/>
  <admst:variable name="args" select=""/>
  <admst:for-each select="arguments">
    <admst:value-of select="position(.)"/>
    <admst:variable name="index" select="%s"/>
    <admst:if test="[not($args='')]">
      <admst:variable name="args" select="$args,"/>
    </admst:if>
    <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
    <admst:variable name="arg$index" select="%s"/>
    <admst:variable name="args" select="$args$(arg$index)"/>
  </admst:for-each>
  <admst:choose>
    <admst:when test="[$arg1='&quot;gdev&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_gdev"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;gmin&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_gmin"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;imax&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_imax"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;imelt&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_imelt"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;iteration&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_iteration"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;scale&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_scale"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;shrink&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_shrink"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;simulatorSubversion&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_simulatorSubversion"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;simulatorVersion&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_simulatorVersion"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;sourceScaleFactor&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_sourceScaleFactor"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;tnom&quot;']">
      <admst:value-to select="/simulator/tmp" value="_circuit_tnom"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;checkjcap&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;maxmosl&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;maxmosw&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;minmosl&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0e-12"/>
    </admst:when>
    <admst:when test="[$arg1='&quot;minmosw&quot;']">
      <admst:value-to select="/simulator/tmp" value="1.0e-12"/>
    </admst:when>
    <admst:otherwise>
      <admst:error format="$function($args) -- not implemented in ngspice interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>


<admst:template match="variable:declaration">
  <admst:for-each select="module/evaluation/variable">
    <admst:assert test="adms[datatypename='variable']" format="expecting datatypename=variable\n"/>
    <admst:if test="[scope='local']">
      <admst:if test="[static='no' and dynamic='yes']">#if defined(_DYNAMIC)\n</admst:if>
      <admst:value-of select="name"/>
      <admst:if test="[type='integer']">int %s;\n</admst:if>
      <admst:if test="[type='real']">double %s=0.0/0.0;\n</admst:if>
      <admst:if test="[type='string']">char* %s;\n</admst:if>
      <admst:if test="[insource='yes']">
        <admst:if test="probe">
          <admst:text format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="probe">
            <admst:value-of select="branch/nnode/name"/>
            <admst:value-of select="branch/pnode/name"/>
            <admst:value-of select="nature/access"/>
            <admst:value-of select="../name"/>
            <admst:text format="double %s_%s%s_%s=0.0;\n"/>
          </admst:for-each>
          <admst:text format="#endif /*_DERIVATE*/\n"/>
        </admst:if>
      </admst:if>
      <admst:if test="[static='no' and dynamic='yes']">#endif /*_DYNAMIC*/\n</admst:if>
    </admst:if>
    <admst:if test="[scope!='local']">
      <admst:if test="[insource='yes']">
        <admst:if test="probe">
          <admst:text format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="probe">
            <admst:value-of select="branch/nnode/name"/>
            <admst:value-of select="branch/pnode/name"/>
            <admst:value-of select="nature/access"/>
            <admst:value-of select="../name"/>
            <admst:text format="double %s_%s%s_%s=0.0;\n"/>
          </admst:for-each>
          <admst:text format="#endif /*_DERIVATE*/\n"/>
        </admst:if>
      </admst:if>
    </admst:if>
  </admst:for-each>
  <admst:reset select="module/evaluation/variable"/>
</admst:template>

<!-- save all variables used for local declaration -->
<admst:template match="block:local:declaration">
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="module/evaluation/variable" select="lhs" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:for-each select="item">
        <admst:apply-templates select="." match="block:local:declaration" required="yes"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="block:local:declaration" required="yes"/>
      <admst:apply-templates select="else" match="block:local:declaration" required="yes"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="block:local:declaration" required="yes"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
    </admst:when>
    <admst:when test="adms[datatypename='callfunction']">
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:error format="case statement: please implement me! (local declaration)\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:value-of select="admst(.)"/>
      <admst:value-of select="adms/datatypename"/>
      <admst:error format="'datatypename=%s': should not be reached %s\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- analog//blockvariable -->
<admst:template match="blockvariable">
  <admst:for-each select="variable">
    <admst:if test="[type='integer']">int %(name);\n</admst:if>
    <admst:if test="[type='real']">double %(name);\n</admst:if>
    <admst:if test="[type='string']">char* %(name);\n</admst:if>
    <admst:text test="[insource='yes']" select="probe" format="double %(../name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
  </admst:for-each>
</admst:template>

<!-- analog//block -->
<admst:template match="block">
  <admst:assert test="[name!='/']" format="expecting subblock\n"/>
  <admst:text format="{\n"/>
  <admst:for-each select="item">
    <admst:value-of select="./adms/datatypename"/>
    <admst:apply-templates select="." match="%s" required="yes"/>
  </admst:for-each>
  <admst:text format="}\n"/>
</admst:template>

<!-- analog/[initializeModel|initializeInstance|initial_model|initial_instance|initial_step|noise] -->
<admst:template match="block:initial">
  <admst:assert test="adms[datatypename='block']" format="expecting datatypename=block\n"/>
  <admst:apply-templates select="." match="block:local:declaration"/>
  <admst:apply-templates select="." match="variable:declaration"/>
  <admst:apply-templates select="." match="block" required="yes"/>
</admst:template>
<admst:template match="analog:initial_instance">
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
          <admst:apply-templates select="[name='initial_instance' or name='initializeInstance']" match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>
<admst:template match="analog:initial_model">
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
          <admst:apply-templates select="[name='initial_model' or name='initializeModel']" match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>
<admst:template match="analog:initial_step">
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
          <admst:apply-templates select="[name='initial_step']" match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>
<admst:template match="analog:noise">
  <admst:if test="code">
    <admst:if test="code/adms[datatypename='block']">
      <admst:for-each select="code/item">
        <admst:if test="adms[datatypename='block']">
          <admst:apply-templates select="[name='noise']" match="block:initial"/>
        </admst:if>
      </admst:for-each>
    </admst:if>
  </admst:if>
</admst:template>

<!-- analog//function: local assignment handling -->
<admst:template match="function:assignment">
  <admst:for-each select="function[class='builtin']">
    <admst:choose>
      <admst:when test="arguments[count(.)=1]">
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="_%s(__%s_%s,"/>
        <admst:join select="arguments" separator=",">
          <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
          <admst:text format="(%s)"/>
        </admst:join>
        <admst:text format=")\n"/>
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
      </admst:when>
      <admst:when test="arguments[count(.)=2]">
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="_%s"/>
        <admst:text test="[name='div']" format="0"/>
        <admst:text format="(__%s_%s,"/>
        <admst:join select="arguments" separator=",">
          <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
          <admst:text format="%s"/>
        </admst:join>
        <admst:text format=")\n"/>
        <admst:value-of select="position(.)-1"/>
        <admst:apply-templates select="." match="function:getname"/>
        <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:value-of select="name"/>
        <admst:error format="%s: function not handled\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
</admst:template>

<!-- analog//function: ddx handling -->
<admst:template match="ddx:function:computation">
  <admst:if test="lhs[insource='yes']">
    <admst:if test="rhs[hasVoltageDependentFunction='yes']">
      <admst:text format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="rhs/function">
        <admst:if test="arguments[count(.)=1]">
          <admst:for-each select="arguments[position(.)=1]">
            <admst:if test="math[dependency!='constant']">
              <admst:value-of select="../position(.)-1"/>
              <admst:apply-templates select=".." match="function:getname"/>
              <admst:text format="double __d_%s_%s=0.0;\n"/>
            </admst:if>
          </admst:for-each>
        </admst:if>
        <admst:if test="arguments[count(.)=2]">
          <admst:for-each select="arguments">
            <admst:if test="[position(.)=1]">
              <admst:if test="[(../name='div') or (math/dependency!='constant')]">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="double __dFx_%s_%s=0.0;\n"/>
              </admst:if>
            </admst:if>
            <admst:if test="[position(.)=2]">
              <admst:if test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="double __dFy_%s_%s=0.0;\n"/>
              </admst:if>
            </admst:if>
          </admst:for-each>
        </admst:if>
      </admst:for-each>
      <admst:text format="#endif /* _DERIVATE */\n"/>
      <admst:text format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="rhs/function">
        <admst:if test="arguments[count(.)=1]">
          <admst:for-each select="arguments[position(.)=1]">
            <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
            <admst:choose>
              <admst:when test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_d_%s(__%s_%s,__d_%s_%s,(%s))\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__d_%s_%s)\n"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_%s(__%s_%s,(%s))\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:if>
        <admst:if test="arguments[count(.)=2]">
          <admst:value-of select="./position(.)-1"/>
          <admst:apply-templates select="." match="function:getname"/>
          <admst:apply-templates select="." match="function:getname"/>
          <admst:text format="_%s(__%s_%s,"/>
          <admst:text test="[name='div']" format="__dFx_%(name)_%(position(.)-1),"/>
          <admst:join select="arguments" separator=",">
            <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
            <admst:text format="%s"/>
          </admst:join>
          <admst:text format=")\n"/>
          <admst:for-each select="arguments">
            <admst:if test="[position(.)=1]">
              <admst:if test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_dx_%s(__dFx_%s_%s,__%s_%s,"/>
                <admst:join select="../arguments" separator=",">
                  <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
                  <admst:text format="%s"/>
                </admst:join>
                <admst:text format=")\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__dFx_%s_%s)\n"/>
              </admst:if>
            </admst:if>
            <admst:if test="[position(.)=2]">
              <admst:if test="math[dependency!='constant']">
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="_dy_%s(__dFy_%s_%s,"/>
                <admst:text test="[../name='div']" format="__dFx_%(../name)_%(../position(.)-1),"/>
                <admst:text format="__%s_%s,"/>
                <admst:join select="../arguments" separator=",">
                  <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
                  <admst:text format="%s"/>
                </admst:join>
                <admst:text format=")\n"/>
                <admst:value-of select="../position(.)-1"/>
                <admst:apply-templates select=".." match="function:getname"/>
                <admst:text format="EXIT_IF_ISNAN(__dFy_%s_%s)\n"/>
              </admst:if>
            </admst:if>
          </admst:for-each>
          <admst:value-of select="position(.)-1"/>
          <admst:apply-templates select="." match="function:getname"/>
          <admst:text format="EXIT_IF_ISNAN(__%s_%s)\n"/>
        </admst:if>
      </admst:for-each>
      <admst:text format="#else\n"/>
    </admst:if>
  </admst:if>
  <admst:apply-templates select="rhs" match="function:assignment"/>
  <admst:if test="lhs[insource='yes']">
    <admst:if test="rhs[hasVoltageDependentFunction='yes']">
      <admst:text format="#endif\n"/>
    </admst:if>
  </admst:if>
</admst:template>

<!-- analog//assignment -->
<admst:template match="assignment">
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#if defined(_DYNAMIC)\n"/>
      </admst:when>
    </admst:choose>
    <admst:text format="{\n"/>
    <admst:for-each select="rhs/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="." match="ddx:function:computation"/>
  </admst:if>
  <admst:if test="lhs[derivate='yes']">
    <admst:text format="#if defined(_DERIVATE)\n"/>
  </admst:if>
  <admst:if test="lhs[insource='yes']">
    <admst:if test="rhs/probe">
      <admst:text format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="rhs/probe">
        <admst:value-of select="."/>
        <admst:value-to select="/simulator/probe" value="%p"/>
        <admst:apply-templates select="../tree" match="subexpression:differentiate"/>
        <admst:value-of select="/simulator/ddx"/>
        <admst:value-of select="branch/nnode/name"/>
        <admst:value-of select="branch/pnode/name"/>
        <admst:value-of select="nature/access"/>
        <admst:value-of select="../../lhs/name"/>
        <admst:text format="%s_%s%s_%s=%s;\n"/>
        <admst:value-of select="branch/nnode/name"/>
        <admst:value-of select="branch/pnode/name"/>
        <admst:value-of select="nature/access"/>
        <admst:value-of select="../../lhs/name"/>
        <admst:text format="EXIT_IF_ISNAN(%s_%s%s_%s)\n"/>
      </admst:for-each>
      <admst:text format="#endif /*_DERIVATE*/\n"/>
    </admst:if>
  </admst:if>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:text format="#if defined(_DYNAMIC)\n"/>
    </admst:when>
  </admst:choose>
  <admst:apply-templates select="lhs" match="variable:lhs" required="yes"/>
  <admst:apply-templates select="rhs" match="expression:stringify:noprobe"/>
  <admst:text format="=%s;\n"/>
  <admst:text format="EXIT_IF_ISNAN("/>
  <admst:apply-templates select="lhs" match="variable:lhs" required="yes"/>
  <admst:text format=")\n"/>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:text format="#endif /*_DYNAMIC*/\n"/>
    </admst:when>
  </admst:choose>
  <admst:if test="lhs[derivate='yes']">
    <admst:text format="#endif /*_DERIVATE*/\n"/>
  </admst:if>
  <admst:if test="lhs[insource='yes']">
    <admst:value-of select="rhs/probe"/>
    <admst:if-inside select="lhs/probe" list="%p">
      <admst:if test="lhs/probe">
        <admst:text format="#if defined(_DERIVATE)\n"/>
        <admst:for-each select="lhs/probe">
          <admst:value-of select="../../rhs/probe"/>
          <admst:if-not-inside select="." list="%p">
            <admst:value-of select="branch/nnode/name"/>
            <admst:value-of select="branch/pnode/name"/>
            <admst:value-of select="nature/access"/>
            <admst:value-of select="../name"/>
            <admst:text format="%s_%s%s_%s=0.0;\n"/>
          </admst:if-not-inside>
        </admst:for-each>
        <admst:text format="#endif /*_DERIVATE*/\n"/>
      </admst:if>
    </admst:if-inside>
  </admst:if>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#endif /* _DYNAMIC */\n"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- analog//contribution -->
<admst:template match="contribution">
  <admst:choose>
    <admst:when test="[whitenoise='no' and flickernoise='no']">
      <admst:apply-templates select="." match="contribution:nonoise" required="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="contribution:noise" required="yes"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="contribution:nonoise">
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#if defined(_DYNAMIC)\n"/>
      </admst:when>
    </admst:choose>
    <admst:text format="{\n"/>
    <admst:for-each select="rhs/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="." match="ddx:function:computation"/>
  </admst:if>
  <admst:apply-templates select="rhs" match="expression:stringify:noprobe"/>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:text format="  _load_dynamic_"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  _load_static_"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="lhs/branch/nnode[grounded='no']">
      <admst:value-of select="lhs/branch/nnode/name"/>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="residual2(%s,%s,%s)\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="residual1(%s,%s)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:for-each select="rhs/probe">
    <admst:value-of select="."/>
    <admst:value-to select="/simulator/probe" value="%p"/>
    <admst:apply-templates select="../tree" match="subexpression:differentiate"/>
    <admst:value-of select="/simulator/ddx"/>
    <admst:choose>
      <admst:when test="..[dynamic='yes']">
        <admst:text format="  _load_dynamic_"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="  _load_static_"/>
      </admst:otherwise>
    </admst:choose>
    <admst:if test="branch/pnode[grounded='no']">
      <admst:if test="../../lhs/branch/pnode[grounded='no']">
        <admst:choose>
          <admst:when test="branch/nnode[grounded='no']">
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian4(%s,%s,%s,%s,%s)\n"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian2p(%s,%s,%s,%s)\n"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian2s(%s,%s,%s,%s)\n"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian1(%s,%s,%s)\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
  </admst:for-each>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
    <admst:if test="[dynamic='yes']">
      <admst:text format="#endif /* _DYNAMIC */\n"/>
    </admst:if>
  </admst:if>
</admst:template>

<!-- analog//conditional -->
<admst:template match="conditional">
  <admst:if test="if[dynamic='yes']">
    <admst:choose>
      <admst:when test="[nilled(else)]">
        <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_ifthen&gt;*/\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_ifthenelse&gt;*/\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
  <admst:if test="if[not(nilled(function[class='builtin']))]">
    <admst:text format="{\n"/>
    <admst:for-each select="if/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="if" match="function:assignment"/>
  </admst:if>
  <admst:apply-templates select="if" match="expression:stringify:noprobe"/>
  <admst:text format="if\n(%s)\n"/>
  <admst:if test="then/adms[datatypename!='block']">
    <admst:text format="{\n"/>
  </admst:if>
  <admst:value-of select="then/adms/datatypename"/>
  <admst:apply-templates select="then" match="%s" required="yes"/>
  <admst:if test="then/adms[datatypename!='block']">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="else">
    <admst:text format="else\n"/>
    <admst:choose>
      <admst:when test="else/adms[datatypename='block']">
        <admst:value-of select="else/adms/datatypename"/>
        <admst:apply-templates select="else" match="%s" required="yes"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="{\n"/>
        <admst:value-of select="else/adms/datatypename"/>
        <admst:apply-templates select="else" match="%s" required="yes"/>
        <admst:text format="}\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
  <admst:if test="if[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="if[dynamic='yes']">
    <admst:choose>
      <admst:when test="[nilled(else)]">
        <admst:text format="#endif /*&lt;/dynamic_ifthen&gt;*/\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="#endif /*&lt;/dynamic_ifthenelse&gt;*/\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- analog//case -->
<admst:template match="case">
  <admst:error format="case statement: please implement me! (inside block)\n"/>
  <admst:text format="/*CASE*/;\n"/>
</admst:template>

<!-- analog//nilled -->
<admst:template match="nilled">
  <admst:text format=";\n"/>
</admst:template>

<!-- analog//whileloop -->
<admst:template match="whileloop">
  <admst:if test="while[dynamic='yes']">
    <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_while&gt;*/\n"/>
  </admst:if>
  <admst:if test="while[not(nilled(function[class='builtin']))]">
    <admst:text format="{\n"/>
    <admst:for-each select="while/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="while" match="function:assignment"/>
  </admst:if>
  <admst:apply-templates select="while" match="expression:stringify:noprobe"/>
  <admst:text format="while\n(%s)\n"/>
  <admst:if test="whileblock/adms[datatypename!='block']">
    <admst:text format="{\n"/>
  </admst:if>
  <admst:value-of select="whileblock/adms/datatypename"/>
  <admst:apply-templates select="whileblock" match="%s" required="yes"/>
  <admst:if test="whileblock/adms[datatypename!='block']">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="while[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
  </admst:if>
  <admst:if test="while[dynamic='yes']">
    <admst:text format="#endif /*&lt;/dynamic_while&gt;*/\n"/>
  </admst:if>
</admst:template>

<!-- analog//callfunctions -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="_strobe("/>
    </admst:when>
    <admst:when test="function[name='\$warning']">
      <admst:text format="_warning("/>
    </admst:when>
    <admst:when test="function[name='\$error']">
      <admst:text format="_error("/>
    </admst:when>
    <admst:when test="function[name='\$finish']">
      <admst:text format="_finish("/>
    </admst:when>
    <admst:when test="function[name='\$stop']">
      <admst:text format="_stop("/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="/simulator/tmp"/>
      <admst:value-of select="function/name"/>
      <admst:error format="function not supported: %s(%s)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:reset select="/simulator/tmp"/>
  <admst:join select="function/arguments" separator=",">
    <admst:apply-templates select="." match="expression:stringify:noprobe"/>%s</admst:join>
  <admst:text format=");\n"/>
</admst:template>

<!-- expression//probe -->
<admst:template match="probe">
  <admst:choose>
    <admst:when test="branch/nnode[grounded='no']">
      <admst:value-of select="branch/nnode/name"/>
      <admst:value-of select="branch/pnode/name"/>
      <admst:value-to select="/simulator/tmp" value="BP(%s,%s)"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="branch/pnode/name"/>
      <admst:value-to select="/simulator/tmp" value="NP(%s)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- expression//node -->
<admst:template match="node">
  <admst:value-of select="name"/>
  <admst:error format="module node not expected here ... %s\n"/>
</admst:template>

<!-- expression//string -->
<admst:template match="string">
  <admst:value-of select="value"/>
  <admst:value-to select="/simulator/tmp" value="&quot;%s&quot;"/>
</admst:template>

<!-- expression//number -->
<admst:template match="number">
  <admst:choose>
    <admst:when test="[scalingunit='1']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="%s"/>
    </admst:when>
    <admst:when test="[scalingunit='E']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+18)"/>
    </admst:when>
    <admst:when test="[scalingunit='P']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+15)"/>
    </admst:when>
    <admst:when test="[scalingunit='T']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+12)"/>
    </admst:when>
    <admst:when test="[scalingunit='G']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+9)"/>
    </admst:when>
    <admst:when test="[scalingunit='M']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+6)"/>
    </admst:when>
    <admst:when test="[scalingunit='k']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+3)"/>
    </admst:when>
    <admst:when test="[scalingunit='h']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+2)"/>
    </admst:when>
    <admst:when test="[scalingunit='D']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e+1)"/>
    </admst:when>
    <admst:when test="[scalingunit='d']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-1)"/>
    </admst:when>
    <admst:when test="[scalingunit='c']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-2)"/>
    </admst:when>
    <admst:when test="[scalingunit='m']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-3)"/>
    </admst:when>
    <admst:when test="[scalingunit='u']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-6)"/>
    </admst:when>
    <admst:when test="[scalingunit='n']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-9)"/>
    </admst:when>
    <admst:when test="[scalingunit='A']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-10)"/>
    </admst:when>
    <admst:when test="[scalingunit='p']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-12)"/>
    </admst:when>
    <admst:when test="[scalingunit='f']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-15)"/>
    </admst:when>
    <admst:when test="[scalingunit='a']">
      <admst:value-of select="value"/>
      <admst:value-to select="/simulator/tmp" value="(%s*1.0e-18)"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="scalingunit"/>
      <admst:error format="scaling unit not supported: %s\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- analog//contribution[noise] -->
<admst:template match="contribution:noise">
  <admst:if test="[flickernoise='yes']">
    <admst:text format="ngspice_flickernoise(%(lhs/branch/pnode/name),%(lhs/branch/nnode/name)"/>
    <admst:for-each select="rhs/tree/arguments">
      <admst:apply-templates select="." match="%(datatypename)"/>
      <admst:value-of select="/simulator/tmp"/>
      <admst:text format=",%s"/>
    </admst:for-each>
    <admst:text test="[count(rhs/tree/arguments)=2]" format=",NULL"/>
  </admst:if>
  <admst:if test="[whitenoise='yes']">
    <admst:text format="ngspice_whitenoise(%(lhs/branch/pnode/name),%(lhs/branch/nnode/name)"/>
    <admst:for-each select="rhs/tree/arguments">
      <admst:apply-templates select="." match="%(datatypename)"/>
      <admst:value-of select="/simulator/tmp"/>
      <admst:text format=",%s"/>
    </admst:for-each>
    <admst:text test="[count(rhs/tree/arguments)=1]" format=",NULL"/>
  </admst:if>
  <admst:text format=")\n"/>
</admst:template>

<!-- variable:rhs -->
<admst:template match="variable">
  <admst:value-of select="name"/>
  <admst:if test="[parametertype='analogfunction']">
    <admst:value-to select="/simulator/tmp" value="%s"/>
  </admst:if>
  <admst:if test="[input='yes' and parametertype='model']">
    <admst:value-to select="/simulator/tmp" value="model-&gt;%s"/>
  </admst:if>
  <admst:if test="[input='yes' and parametertype='instance']">
    <admst:value-to select="/simulator/tmp" value="here-&gt;%s"/>
  </admst:if>
  <admst:if test="[input='no' and scope='global_model']">
    <admst:value-to select="/simulator/tmp" value="model-&gt;%s"/>
  </admst:if>
  <admst:if test="[input='no' and scope='global_instance']">
    <admst:value-to select="/simulator/tmp" value="here-&gt;%s"/>
  </admst:if>
  <admst:if test="[parametertype!='analogfunction' and scope='local']">
    <admst:value-to select="/simulator/tmp" value="%s"/>
  </admst:if>
</admst:template>
<!-- variable:lhs -->
<admst:template match="variable:lhs">
  <admst:text test="[input='yes' and parametertype='model']" format="model-&gt;%(name)"/>
  <admst:text test="[input='yes' and parametertype='instance']" format="here-&gt;%(name)"/>
  <admst:text test="[input='no' and scope='global_model']" format="model-&gt;%(name)"/>
  <admst:text test="[input='no' and scope='global_instance']" format="here-&gt;%(name)"/>
  <admst:text test="[scope='local']" format="%(name)"/>
</admst:template>
<!-- handle analog//callfunctions -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="fprintf(stdout"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="function/name"/>
      <admst:text format="%s: not supported by this interface\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:for-each select="function/arguments">
    <admst:apply-templates select="." match="expression:stringify:noprobe"/>
    <admst:text format=",%s"/>
  </admst:for-each>
  <admst:text format=");\n"/>
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="fprintf(stdout,&quot;\\n&quot;);\n"/>
    </admst:when>
  </admst:choose>
</admst:template>

  <admst:value-to select="/simulator/package_name" value="ngspice"/>
  <admst:value-to select="/simulator/package_tarname" value="ngspice"/>
  <admst:value-to select="/simulator/package_version" value="1.0.0.0"/>
  <admst:value-to select="/simulator/package_string" value="ngspice 1.0.0.0"/>
  <admst:value-to select="/simulator/package_bugreport" value="r29173@users.sourceforge.net"/>

  <admst:for-each select="/module">
    <admst:new datatype="list" arguments="fnoise">
      <admst:variable name="fnoise" select="%(.)"/>
    </admst:new>
    <admst:new datatype="list" arguments="tnoise">
      <admst:variable name="tnoise" select="%(.)"/>
    </admst:new>
    <admst:new datatype="list" arguments="wnoise">
      <admst:variable name="wnoise" select="%(.)"/>
    </admst:new>
    <admst:for-each select="contribution">
      <admst:variable name="contribution" select="%(.)"/>
      <admst:variable name="dependency" select="%(math/dependency)"/>
      <admst:choose>
        <admst:when test="rhs/tree/adms[datatypename='function']/..[name='flicker_noise']">
          <admst:push into="$fnoise/item" select="$contribution" onduplicate="ignore"/>
        </admst:when>
        <admst:when test="[$dependency='constant']/rhs/tree/adms[datatypename='function']/..[name='white_noise']">
          <admst:push into="$tnoise/item" select="$contribution" onduplicate="ignore"/>
        </admst:when>
        <admst:when test="[$dependency!='constant']/rhs/tree/adms[datatypename='function']/..[name='white_noise']">
          <admst:push into="$wnoise/item" select="$contribution" onduplicate="ignore"/>
        </admst:when>
      </admst:choose>
    </admst:for-each>
    <admst:choose>
      <admst:when test="[name='hic0_full']">
        <admst:new datatype="attribute" arguments="ngspicename">
          <admst:push into="../attribute" select="." onduplicate="abort"/>
          <admst:value-to select="value" value="hicum0"/>
        </admst:new>
      </admst:when>
      <admst:when test="[name='hic01_full']">
        <admst:new datatype="attribute" arguments="ngspicename">
          <admst:push into="../attribute" select="." onduplicate="abort"/>
          <admst:value-to select="value" value="hicum01"/>
        </admst:new>
      </admst:when>
      <admst:when test="[name='hic2_full']">
        <admst:new datatype="attribute" arguments="ngspicename">
          <admst:push into="../attribute" select="." onduplicate="abort"/>
          <admst:value-to select="value" value="hicum2"/>
        </admst:new>
      </admst:when>
      <admst:when test="[name='bjt504_va']">
        <admst:new datatype="attribute" arguments="ngspicename">
          <admst:push into="../attribute" select="." onduplicate="abort"/>
          <admst:value-to select="value" value="mextram"/>
        </admst:new>
      </admst:when>
      <admst:when test="[name='psp102']">
        <admst:new datatype="attribute" arguments="ngspicename">
          <admst:push into="../attribute" select="." onduplicate="abort"/>
          <admst:value-to select="value" value="psp102"/>
        </admst:new>
      </admst:when>
      <admst:otherwise>
        <admst:new datatype="attribute" arguments="ngspicename">
          <admst:push into="../attribute" select="." onduplicate="abort"/>
          <admst:value-of select="../name"/>
          <admst:value-to select="value" value="%s"/>
        </admst:new>
      </admst:otherwise>
    </admst:choose>
    <admst:choose>
      <admst:when test="[name='r2_et_cmc' or name='r2_cmc']">
      </admst:when>
      <admst:when test="[name='mosvar']">
        <admst:if test="[nilled(variable[name='c'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,c,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="1">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
      </admst:when>
      <admst:when test="[name='juncap2']">
        <admst:if test="[nilled(variable[name='d'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,d,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="1">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
      </admst:when>
      <admst:when test="[name='vbic' or name='hic0_full' or name='hic2_full' or name='bjt504_va']">
        <admst:if test="[nilled(variable[name='npn'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,npn,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="1">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
        <admst:if test="[nilled(variable[name='pnp'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,pnp,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="0">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
      </admst:when>
      <admst:when test="[name='psp102']">
        <admst:if test="[nilled(variable[name='nmos'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,nmos,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="1">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
        <admst:if test="[nilled(variable[name='pmos'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,pmos,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="1">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
      </admst:when>
      <admst:when test="[name='ekv']">
        <admst:if test="[nilled(variable[name='nmos'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,nmos,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="1">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
        <admst:if test="[nilled(variable[name='pmos'])]">
          <admst:value-of select="analog"/>
          <admst:value-of select="."/>
          <admst:new datatype="variable" arguments="%p,pmos,%p">
            <admst:push into="module/variable" select="." onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="integer"/>
            <admst:value-to select="input" value="yes"/>
            <admst:value-to select="output" value="yes"/>
            <admst:value-to select="parametertype" value="model"/>
            <admst:value-to select="scope" value="global_model"/>
            <admst:new datatype="number" arguments="1">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="../module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
          </admst:new>
        </admst:if>
      </admst:when>

      <admst:otherwise>
        <admst:value-of select="name"/>
        <admst:fatal format="%s: device not handled by the adms ngspice interface\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEitf.h.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEitf.h.xml,v 1.5 2007/04/24 08:59:09 r29173 Exp $
  $Log: ngspiceMODULEitf.h.xml,v $
  Revision 1.5  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">
<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#ifndef DEV_$(module)
#define DEV_$(module)

extern SPICEdev *get_$(module)_info(void);

#endif

</admst:template>


<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sitf.h">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sitf.h: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEinit.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEinit.c.xml,v 1.6 2006/03/05 09:38:41 pnenzi Exp $
  $Log: ngspiceMODULEinit.c.xml,v $
  Revision 1.6  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.5  2006/03/01 14:30:24  pnenzi

  Added mdel, del and dest functions to interface.

  Revision 1.4  2006/02/26 22:09:02  pnenzi

  Added support for pole-zero analysis (experimental).

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">
<admst:template match="code">
#include "config.h"

#include "devdefs.h"

<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;$(module)itf.h&quot;
#include &quot;$(module)ext.h&quot;
#include &quot;$(module)init.h&quot;

SPICEdev $(module)info = {
  {   &quot;$module&quot;,
      &quot;$module created by adms&quot;,
      &amp;$(module)nSize,
      &amp;$(module)nSize,
      $(module)names,
      &amp;$(module)pTSize,
      $(module)pTable,
      &amp;$(module)mPTSize,
      $(module)mPTable,
#ifdef XSPICE
/*----  Fixed by SDB 5.2.2003 to enable XSPICE/tclspice integration  -----*/
        NULL,  /* This is a SPICE device, it has no MIF info data */

        0,     /* This is a SPICE device, it has no MIF info data */
        NULL,  /* This is a SPICE device, it has no MIF info data */

        0,     /* This is a SPICE device, it has no MIF info data */
        NULL,  /* This is a SPICE device, it has no MIF info data */

        0,     /* This is a SPICE device, it has no MIF info data */
        NULL,  /* This is a SPICE device, it has no MIF info data */
/*---------------------------  End of SDB fix   -------------------------*/
#endif
      DEV_DEFAULT
  },

    $(module)par,    /* DEVparam       */
    $(module)mParam,   /* DEVmodParam    */
    $(module)load,     /* DEVload        */
    $(module)setup,    /* DEVsetup       */
    NULL,  /* DEVunsetup     */
    $(module)setup,    /* DEVpzSetup     */
    $(module)temp,     /* DEVtemperature */
    $(module)trunc,    /* DEVtrunc       */
    NULL,         /* DEVfindBranch  */
    $(module)acLoad,   /* DEVacLoad      */
    NULL,         /* DEVaccept      */
    $(module)destroy,  /* DEVdestroy     */
    $(module)mDelete,  /* DEVmodDelete   */
    $(module)delete,   /* DEVdelete      */
    NULL,    /* DEVsetic       */
    $(module)ask,      /* DEVask         */
    $(module)mAsk,     /* DEVmodAsk      */
    $(module)pzLoad,   /* DEVpzLoad      */
    NULL, /* DEVconvTest    */
    NULL,         /* DEVsenSetup    */
    NULL,         /* DEVsenLoad     */
    NULL,         /* DEVsenUpdate   */
    NULL,         /* DEVsenAcLoad   */
    NULL,         /* DEVsenPrint    */
    NULL,         /* DEVsenTrunc    */
    NULL,         /* DEVdisto       */
    NULL,         /* DEVnoise       */
#ifdef CIDER
    NULL,         /* DEVdump       */
    NULL,         /* DEVacct       */
#endif                                                         
    &amp;$(module)iSize,   /* DEVinstSize    */
    &amp;$(module)mSize    /* DEVmodSize     */

};

SPICEdev *
get_$(module)_info(void)
{
    return &amp;$(module)info;
}

</admst:template>


<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sinit.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sinit.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEinit.h.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEinit.h.xml,v 1.5 2007/04/24 08:59:09 r29173 Exp $
  $Log: ngspiceMODULEinit.h.xml,v $
  Revision 1.5  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">
<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#ifndef _$(module)INIT_H
#define _$(module)INIT_H

extern IFparm $(module)pTable[ ];
extern IFparm $(module)mPTable[ ];
extern char *$(module)names[ ];
extern int $(module)pTSize;
extern int $(module)mPTSize;
extern int $(module)nSize;
extern int $(module)iSize;
extern int $(module)mSize;

#endif

</admst:template>


<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sinit.h">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sinit.h: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEext.h.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEext.h.xml,v 1.5 2007/04/24 08:59:09 r29173 Exp $
  $Log: ngspiceMODULEext.h.xml,v $
  Revision 1.5  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">
<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#ifndef __$(module)EXT_H
#define __$(module)EXT_H

<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;$(module)defs.h&quot;

extern int $(module)par(int,IFvalue*,GENinstance*,IFvalue*);
extern int $(module)mParam(int,IFvalue*,GENmodel*);
extern int $(module)load(GENmodel*,CKTcircuit*);
extern int $(module)setup(SMPmatrix*,GENmodel*,CKTcircuit*,int*);
extern int $(module)guesstopology(SMPmatrix *, CKTcircuit *, $(module)model *, $(module)instance *);
extern int $(module)temp(GENmodel*,CKTcircuit*);
extern int $(module)ask(CKTcircuit *,GENinstance*,int,IFvalue*,IFvalue*);
extern int $(module)mAsk(CKTcircuit*,GENmodel *,int, IFvalue*);
extern int $(module)acLoad(GENmodel *,CKTcircuit*);
extern int $(module)convTest(GENmodel *,CKTcircuit*);
extern int $(module)delete(GENmodel*,IFuid,GENinstance**);
extern int $(module)getic(GENmodel*,CKTcircuit*);
extern int $(module)mDelete(GENmodel**,IFuid,GENmodel*);
extern int $(module)noise(int,int,GENmodel*,CKTcircuit*,Ndata*,double*);
extern int $(module)pzLoad(GENmodel*,CKTcircuit*,SPcomplex*);
extern int $(module)trunc(GENmodel*,CKTcircuit*,double*);
extern int $(module)unsetup(GENmodel*,CKTcircuit*);
extern void $(module)destroy(GENmodel**);

#endif

</admst:template>


<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sext.h">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sext.h: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEdefs.h.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEdefs.h.xml,v 1.15 2009/01/01 20:48:48 dwarning Exp $
  $Log: ngspiceMODULEdefs.h.xml,v $
  Revision 1.15  2009/01/01 20:48:48  dwarning
  some cc needs double for isinf macro

  Revision 1.14  2007/07/23 17:24:14  dwarning
  unique limexp behaviour

  Revision 1.13  2007/07/05 10:20:47  r29173
  added declaration of noise variables

  Revision 1.12  2007/05/11 07:19:57  r29173
  added support to 'div' builtin function

  Revision 1.11  2007/02/10 16:08:41  dwarning
  unification for func and derivative

  Revision 1.10  2006/03/07 10:12:12  r29173
  replaced '<' by xml special sequence '&lt;'

  Revision 1.9  2006/03/06 16:36:55  dwarning
  Macros for exp() limiting added.

  Revision 1.8  2006/03/06 12:50:52  r29173
  added support to 'analog functions'

  Revision 1.7  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.6  2006/03/03 08:39:31  r29173
  add simparam definitions when possible

  Revision 1.5  2006/03/02 08:51:08  r29173
  added macro _scale (scaling factor) - always set to 1.0

  Revision 1.4  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.3  2006/02/09 11:25:24  pnenzi

  Latest update from Laurent and Dietmar: (empty instances)

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#ifndef $(module)
#define $(module)

#include &quot;cktdefs.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;gendefs.h&quot;
#include &quot;complex.h&quot;
#include &quot;noisedef.h&quot;

<admst:for-each select="variable">
<admst:value-of select="name"/>
<admst:variable name="variable" select="%s"/>
#ifdef $(variable)
  #warning conflict: $(variable) is declared as a variable of module '$(module)'.
  #warning conflict: However in the API of ngspice '$(variable)' is also defined as a pragma.
  #warning conflict: Pragma '$(variable)' will be undefined.
  #warning conflict: You can solve the confict by renaming variable '$(variable)' in module '$(module)'.
  #undef $(variable)
#endif
</admst:for-each>
<admst:for-each select="node">
<admst:value-of select="name"/>
<admst:variable name="node" select="%s"/>
#ifdef $(variable)
  #warning conflict: $(node) is declared as a node of module '$(module)'.
  #warning conflict: However in the API of ngspice '$(node)' is also defined as a pragma.
  #warning conflict: Pragma '$(node)' will be undefined.
  #warning conflict: You can solve the confict by renaming variable '$(node)' in module '$(module)'.
  #undef $(variable)
#endif
</admst:for-each>

#ifdef NGSPICE_DEBUG_OK
#define NGSPICE_DEBUG \\
{ \\
  if(getenv(&quot;ngspice_debug&quot;)) \\
    $(module)debug(ckt,model,here); \\
  else \\
  { \\
    printf(&quot;  To get more info run your simulation after setting shell variable ngspice_debug to 1\\n&quot;); \\
    printf(&quot;  For example in sh shell just type: export ngspice_debug=1\\n&quot;); \\
  } \\
}
#else
#define NGSPICE_DEBUG
#endif

#define EXIT_IF_ISNAN(var) \\
if(isnan((double) var)) \\
{ \\
  printf(&quot;%%s:%%i:bug:isnan:&quot;#var&quot;\\n&quot;,__FILE__,__LINE__); \\
  printf(&quot;Please send this message to laurent.lemaitre@freescale.com\\n&quot;); \\
  NGSPICE_DEBUG \\
  exit(1); /*__asm__ __volatile__ (&quot;int \$03&quot;);*/ \\
} \\
if(isinf((double) var)) \\
{ \\
  printf(&quot;%%s:%%i:bug:isinf:&quot;#var&quot;\\n&quot;,__FILE__,__LINE__); \\
  printf(&quot;Please send this message to laurent.lemaitre@freescale.com\\n&quot;); \\
  NGSPICE_DEBUG \\
  exit(1); /*__asm__ __volatile__ (&quot;int \$03&quot;);*/ \\
}

/* ngspice \$simparam variables
    gdev                (1/Ohms): Additional conductance to be added to nonlinear branches for conductance homotopy convergence algorithm.
    gmin                (1/Ohms): Minimum conductance placed in parallel with nonlinear branches.
    imax                (Amps)  : Branch current threshold above which the constitutive relation of a nonlinear branch should be linearized.
    imelt               (Amps)  : Branch current threshold indicating device failure.
    iteration                   : Iteration number of the analog solver.
    scale                       : Scale factor for device instance geometry parameters.
    shrink                      : Optical linear shrink factor.
    simulatorSubversion         : The simulator sub-version.
    simulatorVersion            : The simulator version.
    sourceScaleFactor           : Multiplicative factor for independent sources for source stepping homotopy convergence algorithm.
    tnom degrees       (Celsius): Default value of temperature at which model parameters were extracted.
*/

#define _circuit_gdev                ckt-&gt;CKTgmin
#define _circuit_gmin                ckt-&gt;CKTgmin
#define _circuit_imax                1.0
#define _circuit_imelt               1.0
#define _circuit_iteration           1.0
#define _circuit_scale               1.0
#define _circuit_shrink              1.0
#define _circuit_simulatorSubversion 0
#define _circuit_simulatorVersion    3.5
#define _circuit_sourceScaleFactor   1.0
#define _circuit_tnom                ckt-&gt;CKTnomTemp

#define _circuit_temp      ckt-&gt;CKTtemp
#define _scale             1.0

#define _cos(val,arg)            val = cos(arg);
#define _d_cos(val,dval,arg)     val = cos(arg);     dval = (-sin(arg));
#define _sin(val,arg)            val = sin(arg);
#define _d_sin(val,dval,arg)     val = sin(arg);     dval = (cos(arg));
#define _tan(val,arg)            val = tan(arg);
#define _d_tan(val,dval,arg)     val = tan(arg);     dval = (1.0/cos(arg)/cos(arg));
#define _hypot(xy,x,y)           xy = sqrt((x)*(x)+(y)*(y));
#define _dx_hypot(dx,xy,x,y)     dx = (x)/(xy);
#define _dy_hypot(dy,xy,x,y)     dy = (y)/(xy);
#define _max(xy,x,y)             xy = ((x)&gt;(y))?(x):(y);
#define _dx_max(dx,xy,x,y)       dx = ((x)&gt;(y))?1.0:0.0;
#define _dy_max(dy,xy,x,y)       dy = ((x)&gt;(y))?0.0:1.0;
#define _min(xy,x,y)             xy = ((x)&lt;(y))?(x):(y);
#define _dx_min(dx,xy,x,y)       dx = ((x)&lt;(y))?1.0:0.0;
#define _dy_min(dy,xy,x,y)       dy = ((x)&lt;(y))?0.0:1.0;
#define _cosh(val,arg)           val = cosh(arg);
#define _d_cosh(val,dval,arg)    val = cosh(arg);    dval = (sinh(arg));
#define _sinh(val,arg)           val = sinh(arg);
#define _d_sinh(val,dval,arg)    val = sinh(arg);    dval = (cosh(arg));
#define _tanh(val,arg)           val = tanh(arg);
#define _d_tanh(val,dval,arg)    val = tanh(arg);    dval = (1.0/cosh(arg)/cosh(arg));
#define _acos(val,arg)           val = acos(arg);
#define _d_acos(val,dval,arg)    val = acos(arg);    dval = (-1.0/sqrt(1-arg*arg));
#define _asin(val,arg)           val = asin(arg);
#define _d_asin(val,dval,arg)    val = asin(arg);    dval = (+1.0/sqrt(1-arg*arg));
#define _atan(val,arg)           val = atan(arg);
#define _d_atan(val,dval,arg)    val = atan(arg);    dval = (+1.0/(1+arg*arg));
#define _logE(val,arg)           val = log(arg);
#define _d_logE(val,dval,arg)    val = log(arg);     dval = (1.0/arg);
#define _log10(val,arg)          val = log10(arg);
#define _d_log10(val,dval,arg)   val = log10(arg);   dval = (1.0/arg/log(10));
#define _exp(val,arg)            val = exp(arg);
#define _d_exp(val,dval,arg)     val = exp(arg);     dval = val;
#define _sqrt(val,arg)           val = sqrt(arg);
#define _d_sqrt(val,dval,arg)    val = sqrt(arg);    dval = (1.0/val/2.0);
#define _pow(xy,x,y)             xy = pow(x,y);
#define _dx_pow(dx,xy,x,y)       dx = (x==0.0)?0.0:((y/x)*xy);
#define _dy_pow(dy,xy,x,y)       dy = (x==0.0)?0.0:((log(x)/exp(0.0))*xy);

#define _div1(x,y)               ((x)/(y))
#define _div0(xy,x,y)            xy=(x)/(y);
#define _div(xy,dx,x,y)          dx=1/(y); xy=(x)*dx;
#define _dx_div(dx,xy,x,y)
#define _dy_div(dy,dx,xy,x,y)    dy = -xy*dx;

#define _limexp(val,arg)         val = ((arg)&lt;(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90)));
#define _d_limexp(val,dval,arg)  val = ((arg)&lt;(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90))); dval = val;
#define _fabs(val,arg)           val = fabs(arg);
#define _d_fabs(val,dval,arg)    val = fabs(arg);    dval = (((val)&gt;=0)?(+1.0):(-1.0));
#define _abs(val)                ((val)&lt;(0) ? (-(val)):(val))

/* declarations for $(module) MOSFETs */

/* information needed for each instance */
typedef struct s$(module)instance {
  struct s$(module)model *$(module)modPtr;           /* pointer to model */
  struct s$(module)instance *$(module)nextInstance;  /* pointer to next instance of current model*/
  IFuid $(module)name; /* pointer to character string naming this instance */
  int $(module)owner;  /* number of owner process */
  int $(module)state; /* index into state table for this device */

  /* node */
<admst:for-each select="node[grounded='no']">
  <admst:value-of select="name"/>
  <admst:text format="  int %sNode;"/>
  <admst:if test="attribute[name='info']">
    <admst:value-of select="."/>
    <admst:text format="  /*%s*/"/>
  </admst:if>
  <admst:text format="\n"/>
</admst:for-each>
  /* instance parameters */
<admst:for-each select="variable[parametertype='instance' and input='yes']">
  <admst:value-of select="name"/>
  <admst:value-of select="name"/>
  <admst:apply-templates select="." match="dectype"/>
  <admst:text format="%s;\n"/>
  <admst:text format="  unsigned %s_Given  :1;"/>
  <admst:if test="attribute[name='info']">
    <admst:value-of select="."/>
    <admst:text format="  /*%s*/"/>
  </admst:if>
  <admst:text format="\n"/>
</admst:for-each>
 // noise\n
  <admst:text select="$fnoise/item" format="  double fpnoise%(index($fnoise/item,.)), fenoise%(index($fnoise/item,.));\n"/>
  <admst:text select="$tnoise/item" format="  double tnoise%(index($tnoise/item,.));\n"/>
  <admst:text select="$wnoise/item" format="  double wnoise%(index($wnoise/item,.));\n"/>

  /* variables */
<admst:for-each select="variable[input='no' and scope='global_instance']">
  <admst:value-of select="name"/>
  <admst:apply-templates select="." match="dectype"/>
  <admst:text format="%s;\n"/>
  <admst:for-each select="attribute[name='info']">
    <admst:value-of select="."/>
    <admst:text format="  /*%s*/"/>
  </admst:for-each>
</admst:for-each>
  /* states */
<admst:for-each select="source[dynamic='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:text format="  int state_%s_%s;\n"/>
</admst:for-each>
  /* pointer to sparse matrix (+ values)*/
<admst:for-each select="jacobian">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  double *PTR_J_%s_%s;\n"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="    int PTR_J_%s_%s_required;\n"/>
  <admst:if test="[static='yes']">
    <admst:value-of select="column/name"/>
    <admst:value-of select="row/name"/>
    <admst:text format="    double JSVAL_%s_%s;\n"/>
  </admst:if>
  <admst:if test="[dynamic='yes']">
    <admst:value-of select="column/name"/>
    <admst:value-of select="row/name"/>
    <admst:text format="    double JDVAL_%s_%s;\n"/>
  </admst:if>
</admst:for-each>

#define $(module)numStates 0

} $(module)instance ;


/* per model data */

typedef struct s$(module)model {         /* model structure */
  int $(module)modType;        /* type index of this device type */
  struct s$(module)model *$(module)nextModel; /* pointer to next possible model in linked list */
  $(module)instance * $(module)instances;  /* pointer to list of instances that have this model */
  IFuid $(module)modName;         /* pointer to the name of this model */

  /* model parameters */
  <admst:for-each select="variable[parametertype='model' and input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:apply-templates select="." match="dectype"/>
    <admst:text format="%s;\n"/>
    <admst:text format="  unsigned %s_Given  :1;"/>
    <admst:if test="attribute[name='info']">
      <admst:value-of select="."/>
      <admst:text format="  /*%s*/"/>
    </admst:if>
    <admst:text format="\n"/>
  </admst:for-each>
  /* variable */
  <admst:for-each select="variable[input='no' and scope='global_model']">
    <admst:value-of select="name"/>
    <admst:apply-templates select="." match="dectype"/>
    <admst:text format="%s;\n"/>
    <admst:for-each select="attribute[name='info']">
      <admst:value-of select="."/>
      <admst:text format="  /*%s*/"/>
    </admst:for-each>
  </admst:for-each>

} $(module)model;

  <admst:text format="  /* flags */\n"/>
  <admst:text format="typedef enum {\n"/>
  <admst:for-each select="variable[parametertype='model' and input='yes']">
    <admst:value-of select="name"/>
    <admst:text format="  $(module)_model_%s,\n"/>
  </admst:for-each>
    <admst:text format="  DUMMY_MODEL"/>
  <admst:text format="\n} e_$(module)_model;\n"/>
  <admst:text format="typedef enum {\n"/>
  <admst:for-each select="variable[parametertype='instance' and input='yes']">
    <admst:value-of select="name"/>
    <admst:text format="  $(module)_instance_%s,\n"/>
  </admst:for-each>
  <admst:text format="  DUMMY_INSTANCE"/>
  <admst:text format="\n} e_$(module)_instance;\n"/>

<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;$(module)ext.h&quot;
<admst:if test="[not(nilled(analogfunction))]">
#include &quot;analogfunction.h&quot;
</admst:if>

#endif /*$(module)*/

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sdefs.h">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sdefs.h: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEask.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEask.c.xml,v 1.5 2007/04/24 08:59:09 r29173 Exp $
  $Log: ngspiceMODULEask.c.xml,v $
  Revision 1.5  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">


<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;const.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)ask(CKTcircuit *ckt, GENinstance *inst, int which, IFvalue *value, IFvalue *select)
{
  $(module)instance *instance = ($(module)instance*)inst;
  switch (which) {
  <admst:for-each select="variable[parametertype='instance' and input='yes']">
    <admst:value-of select="name"/>
    <admst:text format="  case  $(module)_instance_%s  :\n"/>
    <admst:choose>
      <admst:when test="[type='real']">
        <admst:value-of select="name"/>
        <admst:text format="    value->rValue = instance->%s;\n"/>
      </admst:when>
      <admst:when test="[type='integer']">
        <admst:value-of select="name"/>
        <admst:text format="    value->iValue = instance->%s;\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="parameter of type 'string' not supported\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format="    return OK;\n"/>
  </admst:for-each>
  default:
    return(-1);
  }
  return(-1);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sask.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sask.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEmask.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEmask.c.xml,v 1.5 2008/01/06 17:45:33 dwarning Exp $
  $Log: ngspiceMODULEmask.c.xml,v $
  Revision 1.5  2008/01/06 17:45:33  dwarning
  add NL at the EOF

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">


<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;const.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;devdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)mAsk(CKTcircuit *ckt, GENmodel *inst, int which, IFvalue *value)
{
  $(module)model *model = ($(module)model *)inst;
  switch (which) {
  <admst:for-each select="variable[parametertype='model' and input='yes']">
    <admst:value-of select="name"/>
    <admst:text format="  case  $(module)_model_%s  :\n"/>
    <admst:choose>
      <admst:when test="[type='real']">
        <admst:value-of select="name"/>
        <admst:text format="    value->rValue = model->%s;\n"/>
      </admst:when>
      <admst:when test="[type='integer']">
        <admst:value-of select="name"/>
        <admst:text format="    value->iValue = model->%s;\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="parameter of type 'string' not supported\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:text format="    return OK;\n"/>
  </admst:for-each>
  default:
    return(-1);
  }
  return(-1);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%smask.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%smask.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEpar.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEpar.c.xml,v 1.5 2007/04/24 08:59:09 r29173 Exp $
  $Log: ngspiceMODULEpar.c.xml,v $
  Revision 1.5  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;const.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)par(int param, IFvalue *value, GENinstance *inst, IFvalue *select)
{
  $(module)instance *myinstance = ($(module)instance*)inst;
  switch (param) {
  <admst:for-each select="variable[parametertype='instance' and input='yes']">
    <admst:value-of select="name"/>
    <admst:text format="  case  $(module)_instance_%s  :\n"/>
    <admst:choose>
      <admst:when test="[type='real']">
        <admst:value-of select="name"/>
        <admst:text format="    myinstance->%s = value->rValue;\n"/>
      </admst:when>
      <admst:when test="[type='integer']">
        <admst:value-of select="name"/>
        <admst:text format="    myinstance->%s = value->iValue;\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="parameter of type 'string' not supported\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:value-of select="name"/>
    <admst:text format="    myinstance->%s_Given = TRUE;\n"/>
    <admst:text format="    break;\n"/>
  </admst:for-each>
  default:
    return(-1);
  }
  return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%spar.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%spar.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEmpar.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEmpar.c.xml,v 1.5 2007/04/24 08:59:09 r29173 Exp $
  $Log: ngspiceMODULEmpar.c.xml,v $
  Revision 1.5  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">


<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;const.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)mParam(int param, IFvalue *value, GENmodel *inMod)
{
  $(module)model *mod = ($(module)model*)inMod;
  switch (param) {

  <admst:for-each select="variable[parametertype='model' and input='yes']">
    <admst:value-of select="name"/>
    <admst:text format="  case  $(module)_model_%s  :\n"/>
    <admst:choose>
      <admst:when test="[type='real']">
        <admst:value-of select="name"/>
        <admst:text format="    mod->%s = value->rValue;\n"/>
      </admst:when>
      <admst:when test="[type='integer']">
        <admst:value-of select="name"/>
        <admst:text format="    mod->%s = value->iValue;\n"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="parameter of type 'string' not supported\n"/>
      </admst:otherwise>
    </admst:choose>
    <admst:value-of select="name"/>
    <admst:text format="    mod->%s_Given = TRUE;\n"/>
    <admst:text format="    break;\n"/>
  </admst:for-each>
  default:
    return(-1);
  }
  return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%smpar.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%smpar.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEload.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEload.c.xml,v 1.8 2007/07/05 09:44:11 r29173 Exp $
  $Log: ngspiceMODULEload.c.xml,v $
  Revision 1.8  2007/07/05 09:44:11  r29173
  added new evaluate function (support of ddx operator used inside contribs)

  Revision 1.7  2007/05/05 21:11:46  dwarning
  One additional NL prevent problems in vbicload.c

  Revision 1.6  2007/04/30 13:10:35  r29173
  improved 'guesstopology'
  fixed implementation of macro 'noise'
  when building 'load' traverse block 'noise'

  Revision 1.5  2007/04/26 13:04:34  r29173
  added cases initializeModel, initiliazeInstance (block name used by psp102)

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
#define NGSPICE_DEBUG_OK

<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;const.h&quot;
#include &quot;trandefs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;devdefs.h&quot;
#include &quot;suffix.h&quot;

/*fixme: noise not implemented in ngspice*/
#define ngspice_flickernoise(p,n,mag,freq,info)\\
{\\
}
#define ngspice_whitenoise(p,n,mag,info)\\
{\\
}

#define NP(p) *(ckt-&gt;CKTrhsOld+here-&gt;p ## Node)
#define BP(p,n) (NP(p)-NP(n))
#define DBGNODE(p) printf(#p &quot;=%i - v=%e\\n&quot;,here-&gt;p ## Node,NP(p));

<admst:apply-templates select="." match="debug:strobe"/>

#define _STATIC
#define _DYNAMIC
#define _DERIVATE

#define _load_static_residual2(p,n,v)\\
  *(ckt->CKTrhs+here->p ## Node)-=v;\\
  *(ckt->CKTrhs+here->n ## Node)+=v;
#define _load_static_residual1(p,v)\\
  *(ckt->CKTrhs+here->p ## Node)-=v;

#define _load_static_jacobian4(Sp,Sn,Pp,Pn,v)\\
  _load_static_residual2(Sp,Sn,-v*BP(Pp,Pn))\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  *(here->PTR_J_ ## Sn ## _ ## Pn)+=v;\\
  *(here->PTR_J_ ## Sp ## _ ## Pn)-=v;\\
  *(here->PTR_J_ ## Sn ## _ ## Pp)-=v;\\
  (here->JSVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here->JSVAL_ ## Sn ## _ ## Pn)+=v;\\
  (here->JSVAL_ ## Sp ## _ ## Pn)-=v;\\
  (here->JSVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_static_jacobian2s(Sp,Sn,Pp,v)\\
  _load_static_residual2(Sp,Sn,-v*NP(Pp))\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  *(here->PTR_J_ ## Sn ## _ ## Pp)-=v;\\
  (here->JSVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here->JSVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_static_jacobian2p(Sp,Pp,Pn,v)\\
  _load_static_residual1(Sp,-v*BP(Pp,Pn))\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  *(here->PTR_J_ ## Sp ## _ ## Pn)-=v;\\
  (here->JSVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here->JSVAL_ ## Sp ## _ ## Pn)-=v;
#define _load_static_jacobian1(Sp,Pp,v)\\
  _load_static_residual1(Sp,-v*NP(Pp))\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  (here->JSVAL_ ## Sp ## _ ## Pp)+=v;

#define _load_dynamic_residual2(p,n,v)\\
if(ChargeComputationNeeded)\\
{\\
  int error;\\
  double unused;\\
  *(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n)=v;\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_##n)=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n);\\
  error = NIintegrate(ckt,&amp;unused,&amp;unused,0.0,here-&gt;state_##p##_##n);\\
  if(error) return(error);\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_##n+1) = *(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n+1);\\
  *(ckt->CKTrhs+here->p##Node)-=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n+1);\\
  *(ckt->CKTrhs+here->n##Node)+=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n+1);\\
}
#define _load_dynamic_residual1(p,v)\\
if(ChargeComputationNeeded)\\
{\\
  int error;\\
  double unused;\\
  *(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND)=v;\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_GND)=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND);\\
  error = NIintegrate(ckt,&amp;unused,&amp;unused,0.0,here-&gt;state_##p##_GND);\\
  if(error) return(error);\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_GND+1) = *(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND+1);\\
  *(ckt->CKTrhs+here->p##Node)-=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND+1);\\
}

#define _load_dynamic_jacobian4(Sp,Sn,Pp,Pn,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt->CKTag[0];\\
  double ceq=geq*BP(Pp,Pn);\\
  *(ckt->CKTrhs+here->Sp##Node)+=ceq;\\
  *(ckt->CKTrhs+here->Sn##Node)-=ceq;\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
  *(here->PTR_J_ ## Sn ## _ ## Pn)+=geq;\\
  *(here->PTR_J_ ## Sp ## _ ## Pn)-=geq;\\
  *(here->PTR_J_ ## Sn ## _ ## Pp)-=geq;\\
}\\
  (here->JDVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here->JDVAL_ ## Sn ## _ ## Pn)+=v;\\
  (here->JDVAL_ ## Sp ## _ ## Pn)-=v;\\
  (here->JDVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_dynamic_jacobian2s(Sp,Sn,Pp,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt->CKTag[0];\\
  double ceq=geq*NP(Pp);\\
  *(ckt->CKTrhs+here->Sp##Node)+=ceq;\\
  *(ckt->CKTrhs+here->Sn##Node)-=ceq;\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
  *(here->PTR_J_ ## Sn ## _ ## Pp)-=geq;\\
}\\
  (here->JDVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here->JDVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_dynamic_jacobian2p(Sp,Pp,Pn,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt->CKTag[0];\\
  double ceq=geq*BP(Pp,Pn);\\
  *(ckt->CKTrhs+here->Sp##Node)+=ceq;\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
  *(here->PTR_J_ ## Sp ## _ ## Pn)-=geq;\\
}\\
  (here->JDVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here->JDVAL_ ## Sp ## _ ## Pn)-=v;
#define _load_dynamic_jacobian1(Sp,Pp,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt->CKTag[0];\\
  double ceq=geq*NP(Pp);\\
  *(ckt->CKTrhs+here->Sp##Node)+=ceq;\\
  *(here->PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
}\\
(here->JDVAL_ ## Sp ## _ ## Pp)+=v;

int $(module)load(inModel,ckt)
     GENmodel *inModel;
     register CKTcircuit *ckt;
     /* actually load the current value into the 
      * sparse matrix previously provided 
      */
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  int ChargeComputationNeeded =  
                 ((ckt->CKTmode &amp; (MODEAC | MODETRAN | MODEINITSMSIG)) ||
                 ((ckt->CKTmode &amp; MODETRANOP) &amp;&amp; (ckt->CKTmode &amp; MODEUIC)))
                 ? 1 : 0;

  for ( ; model != NULL; model = model->$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model->$(module)instances; here != NULL ; here = here->$(module)nextInstance)
    {
{
<admst:for-each select="jacobian[static='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  here->JSVAL_%s_%s=0.0;\n"/>
</admst:for-each>
<admst:for-each select="jacobian[dynamic='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  here->JDVAL_%s_%s=0.0;\n"/>
</admst:for-each>
}
{
#include &quot;$module.hxx&quot;
}
    } /* End of Instance */
  } /* End of Model */
  return(OK);
}

</admst:template>

<!-- analog/![initializeModel|initializeInstance|initial_model|initial_instance|initial_step|noise] -->
<admst:template match="debug:strobe">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

  <admst:text format="void $(module)debug (CKTcircuit *ckt, $(module)model *model, $(module)instance *here)\n"/>
  <admst:text format="{\n"/>
  <admst:for-each select="node[grounded='no']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:text format="  fprintf(stdout,&quot;voltage: %s=%%e\\n&quot;,NP(%s));\n"/>
  </admst:for-each>
  <admst:for-each select="variable[input='yes']">
    <admst:choose>
      <admst:when test="[type='integer']">
        <admst:apply-templates select="." match="variable"/>
        <admst:value-of select="/simulator/tmp"/>
        <admst:value-of select="name"/>
        <admst:value-of select="parametertype"/>
        <admst:text format="  fprintf(stdout,&quot;Parameter: %s: %s=%%i\\n&quot;,%s);\n"/>
      </admst:when>
      <admst:when test="[type='real']">
        <admst:apply-templates select="." match="variable"/>
        <admst:value-of select="/simulator/tmp"/>
        <admst:value-of select="name"/>
        <admst:value-of select="parametertype"/>
        <admst:text format="  fprintf(stdout,&quot;Parameter: %s: %s=%%e\\n&quot;,%s);\n"/>
      </admst:when>
    </admst:choose>
  </admst:for-each>
  <admst:for-each select="variable[input='no' and scope='global_model' and setinmodel='yes' and insource='yes']">
    <admst:choose>
      <admst:when test="[type='integer']">
        <admst:apply-templates select="." match="variable"/>
        <admst:value-of select="/simulator/tmp"/>
        <admst:value-of select="name"/>
        <admst:text format="  fprintf(stdout,&quot;model: %s=%%i\\n&quot;,%s);\n"/>
      </admst:when>
      <admst:when test="[type='real']">
        <admst:apply-templates select="." match="variable"/>
        <admst:value-of select="/simulator/tmp"/>
        <admst:value-of select="name"/>
        <admst:text format="  fprintf(stdout,&quot;model: %s=%%e\\n&quot;,%s);\n"/>
      </admst:when>
    </admst:choose>
  </admst:for-each>
  <admst:for-each select="variable[input='no' and scope='global_instance' and setininstance='yes' and insource='yes']">
    <admst:choose>
      <admst:when test="[type='integer']">
        <admst:apply-templates select="." match="variable"/>
        <admst:value-of select="/simulator/tmp"/>
        <admst:value-of select="name"/>
        <admst:text format="  fprintf(stdout,&quot;instance: %s=%%i\\n&quot;,%s);\n"/>
      </admst:when>
      <admst:when test="[type='real']">
        <admst:apply-templates select="." match="variable"/>
        <admst:value-of select="/simulator/tmp"/>
        <admst:value-of select="name"/>
        <admst:text format="  fprintf(stdout,&quot;instance: %s=%%e\\n&quot;,%s);\n"/>
      </admst:when>
    </admst:choose>
  </admst:for-each>
  <admst:text format="}\n"/>
</admst:template>

<admst:template match="analog:evaluate">
  <admst:if test="code">
    <admst:assert test="code/adms[datatypename='block']" format="expecting datatypename=block\n"/>
    <admst:for-each select="code/item">
      <admst:if test="adms[datatypename='block']">
        <admst:if test="[name!='initial_model' and name!='initial_instance' and name!='initializeModel' and name!='initializeInstance'
           and name!='initial_step']">
          <admst:apply-templates select="." match="block:local:declaration"/>
        </admst:if>
      </admst:if>
      <admst:if test="adms[datatypename!='block']">
        <admst:apply-templates select="." match="block:local:declaration"/>
      </admst:if>
    </admst:for-each>
    <admst:apply-templates select="code" match="variable:declaration"/>
    <admst:for-each select="code/item">
      <admst:choose>
        <admst:when test="adms[datatypename!='block']">
          <admst:value-of select="./adms/datatypename"/>
          <admst:apply-templates select="." match="%s"/>
        </admst:when>
        <admst:otherwise>
        <admst:if test="[name!='initial_model' and name!='initial_instance' and name!='initializeModel' and name!='initializeInstance'
             and name!='initial_step']">
            <admst:apply-templates select="." match="block"/>
          </admst:if>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
  </admst:if>
</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sload.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sload.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEacld.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEacld.c.xml,v 1.5 2006/03/05 09:38:41 pnenzi Exp $
  $Log: ngspiceMODULEacld.c.xml,v $
  Revision 1.5  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.4  2006/02/21 10:27:10  r29173
  removed printf statements  used for debug purpose

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)acLoad(GENmodel *inModel, CKTcircuit *ckt)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  for ( ; model != NULL; model = model->$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model->$(module)instances; here != NULL ; here = here->$(module)nextInstance)
    {
<admst:for-each select="jacobian[static='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  if(here->PTR_J_%s_%s_required) *(here->PTR_J_%s_%s)+=here->JSVAL_%s_%s;\n"/>
</admst:for-each>
<admst:for-each select="jacobian[dynamic='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  if(here->PTR_J_%s_%s_required) *(here->PTR_J_%s_%s+1)+=ckt->CKTomega*here->JDVAL_%s_%s;\n"/>
</admst:for-each>
    } /* End of MOSFET Instance */
  } /* End of Model Instance */
  return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sacld.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sacld.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEpzld.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEpzld.c.xml,v 1.2 2006/03/05 09:38:41 pnenzi Exp $
  $Log: ngspiceMODULEpzld.c.xml,v $
  Revision 1.2  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.1  2006/02/26 22:09:03  pnenzi

  Added support for pole-zero analysis (experimental).

  
-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;complex.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)pzLoad(GENmodel *inModel, CKTcircuit *ckt, SPcomplex *s)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  for ( ; model != NULL; model = model->$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model->$(module)instances; here != NULL ; here = here->$(module)nextInstance)
    {
<admst:for-each select="jacobian[static='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  if(here->PTR_J_%s_%s_required) *(here->PTR_J_%s_%s)+=here->JSVAL_%s_%s *(s->real);\n"/>
</admst:for-each>
<admst:for-each select="jacobian[dynamic='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  if(here->PTR_J_%s_%s_required) *(here->PTR_J_%s_%s)+=here->JDVAL_%s_%s *(s->real);\n"/>
</admst:for-each>
<admst:for-each select="jacobian[dynamic='yes']">
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:value-of select="column/name"/>
  <admst:value-of select="row/name"/>
  <admst:text format="  if(here->PTR_J_%s_%s_required) *(here->PTR_J_%s_%s+1)+=here->JDVAL_%s_%s *(s->imag);\n"/>
</admst:for-each>
    } /* End of MOSFET Instance */
  } /* End of Model Instance */
  return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%spzld.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%spzld.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEtemp.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEtemp.c.xml,v 1.5 2007/04/24 08:59:09 r29173 Exp $
  $Log: ngspiceMODULEtemp.c.xml,v $
  Revision 1.5  2007/04/24 08:59:09  r29173
  added missing new lines (due to changes in adms225)
  renamed pspva to psp102

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;smpdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;const.h&quot;
#include &quot;sperror.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;suffix.h&quot;

#define _STATIC
#define _DYNAMIC

int $(module)temp(GENmodel *inModel, CKTcircuit *ckt)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  for ( ; model != NULL; model = model->$(module)nextModel )
  {

<admst:apply-templates select="analog" match="analog:initial_model" required="yes"/>
    /* loop through all the instances of the model */
    for (here = model->$(module)instances; here != NULL ; here = here->$(module)nextInstance)
    {

<admst:apply-templates select="analog" match="analog:initial_instance" required="yes"/>
    } /* End of MOSFET Instance */
  } /* End of Model Instance */
  return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%stemp.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%stemp.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEtrunc.c.xml" ?>

<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEtrunc.c.xml,v 1.1 2006/03/10 09:55:53 pnenzi Exp $
  $Log: ngspiceMODULEtrunc.c.xml,v $
  Revision 1.1  2006/03/10 09:55:53  pnenzi

  Truncation error calculation.


-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)trunc(GENmodel *inModel, CKTcircuit *ckt, double *timeStep)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;

#ifdef STEPDEBUG
    double debugtemp;
#endif /* STEPDEBUG */  
  
  for ( ; model != NULL; model = model->$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model->$(module)instances; here != NULL ; here = here->$(module)nextInstance)
    {
#ifdef STEPDEBUG
            debugtemp = *timeStep;
#endif /* STEPDEBUG */   
 
    <admst:for-each select="source[dynamic='yes']">
    <admst:value-of select="branch/nnode/name"/>
    <admst:value-of select="branch/pnode/name"/>
            CKTterr(here->state_%s_%s, ckt, timeStep);
    </admst:for-each>
    
 
#ifdef STEPDEBUG
            if(debugtemp != *timeStep)
	    {  printf("device %%s reduces step from %%g to %%g\\n",
                       here->$(module)name,debugtemp,*timeStep);
            }
#endif /* STEPDEBUG */
   
    } /* End of Instance */
  } /* End of Model */
  return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%strunc.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%strunc.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEsetup.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEsetup.c.xml,v 1.5 2006/03/06 12:50:15 r29173 Exp $
  $Log: ngspiceMODULEsetup.c.xml,v $
  Revision 1.5  2006/03/06 12:50:15  r29173
  added support to 'analog functions'

  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;smpdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;const.h&quot;
#include &quot;sperror.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;suffix.h&quot;

int $(module)setup (SMPmatrix *matrix, GENmodel *inModel, CKTcircuit *ckt, int *states)
     /* load the $(module) device structure with those pointers needed later 
      * for fast matrix loading 
      */
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  
  /*  loop through all the $(module) device models */
  for ( ;model != NULL ;model = model->$(module)nextModel )
  {
<admst:for-each select="variable[parametertype='model' and input='yes']">
  <admst:if test="default[not(nilled(function[class='builtin']))]">
    <admst:text format="{\n"/>
    <admst:for-each select="default/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="default" match="function:assignment"/>
  </admst:if>
  <admst:apply-templates select="default" match="expression:stringify:noprobe"/>
<admst:value-of select="name"/>
<admst:value-of select="name"/>
    if(model-&gt;%s_Given == FALSE) model-&gt;%s=%s;
<admst:if test="default[not(nilled(function[class='builtin']))]">
  <admst:text format="}\n"/>
</admst:if>
</admst:for-each>
    for ( here = model->$(module)instances ;here != NULL ; here = here->$(module)nextInstance )
    {
<admst:for-each select="variable[parametertype='instance' and input='yes']">
  <admst:if test="default[not(nilled(function[class='builtin']))]">
    <admst:text format="{\n"/>
    <admst:for-each select="default/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="default" match="function:assignment"/>
  </admst:if>
  <admst:apply-templates select="default" match="expression:stringify:noprobe"/>
<admst:value-of select="name"/>
<admst:value-of select="name"/>
    if(here-&gt;%s_Given == FALSE) here-&gt;%s=%s;
<admst:if test="default[not(nilled(function[class='builtin']))]">
  <admst:text format="}\n"/>
</admst:if>
</admst:for-each>
<admst:if test="node[location='internal']">
      /* Internal Nodes */
      {
<admst:for-each select="node[location='internal']">
<admst:variable name="info" select="no info"/>
<admst:for-each select="attribute[name='info']">
  <admst:value-of select="value"/>
  <admst:variable name="info" select="%s"/>
</admst:for-each>
<admst:value-of select="name"/>
        here->%sNode = -1;
</admst:for-each>
      }
</admst:if>
      /* set states */
<admst:for-each select="source[dynamic='yes']">
<admst:value-of select="branch/nnode/name"/>
<admst:value-of select="branch/pnode/name"/>
      here->state_%s_%s = *states; *states += 2;
</admst:for-each>
      /* set Sparse Matrix Pointers */
<admst:for-each select="jacobian">
<admst:value-of select="column/name"/>
<admst:value-of select="row/name"/>
      here-&gt;PTR_J_%s_%s_required=0;
</admst:for-each>

      $(module)guesstopology(matrix,ckt,model,here);

      /* Internal Nodes */
      {
        int error;
        CKTnode *tmp;
<admst:for-each select="node[location='internal']">
<admst:variable name="info" select="no info"/>
<admst:for-each select="attribute[name='info']">
  <admst:value-of select="value"/>
  <admst:variable name="info" select="%s"/>
</admst:for-each>
<admst:value-of select="name"/>
<admst:value-of select="name"/>
        if(here->%sNode == -1)
        {
          error=CKTmkVolt(ckt,&amp;tmp,here-&gt;$(module)name,&quot;$info&quot;);
          if(error) return(error);
          here->%sNode = tmp->number;
        }
</admst:for-each>
      }
<admst:for-each select="jacobian">
<admst:value-of select="column/name"/>
<admst:value-of select="row/name"/>
        if(here-&gt;PTR_J_%s_%s_required==1)
        {
<admst:value-of select="column/name"/>
<admst:value-of select="row/name"/>
<admst:value-of select="column/name"/>
<admst:value-of select="row/name"/>
          here-&gt;PTR_J_%s_%s=SMPmakeElt(matrix,here-&gt;%sNode,here-&gt;%sNode);
        }
</admst:for-each>

    }
  }
  return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%ssetup.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%ssetup.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEdel.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEdel.c.xml,v 1.2 2006/03/05 09:38:41 pnenzi Exp $
  $Log: ngspiceMODULEdel.c.xml,v $
  Revision 1.2  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.1  2006/03/01 14:30:24  pnenzi

  Added mdel, del and dest functions to interface.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)delete(GENmodel *inModel, IFuid name, GENinstance **inInst)

{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance **fast =($(module)instance**)inInst;
  
  $(module)instance **prev = NULL;
  $(module)instance *here;
  
  for ( ; model ; model = model->$(module)nextModel ) {
      prev = &amp;(model->$(module)instances);  
      for (here = *prev; here ; here  = *prev) {
          if(here->$(module)name == name || (fast &amp;&amp; here==*fast) ) {
	      *prev = here->$(module)nextInstance;
	      FREE(here);
	      return(OK);
	      }
         
    } 
  } 
  return(E_NODEV);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sdel.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sdel.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEmdel.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEmdel.c.xml,v 1.2 2006/03/05 09:38:41 pnenzi Exp $
  $Log: ngspiceMODULEmdel.c.xml,v $
  Revision 1.2  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.1  2006/03/01 14:30:24  pnenzi

  Added mdel, del and dest functions to interface.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;sperror.h&quot;
#include &quot;suffix.h&quot;

int $(module)mDelete(GENmodel **inModel, IFuid modname, GENmodel *kill)

{
  register $(module)model **model = ($(module)model**)inModel;
  register $(module)model *modfast =($(module)model*)kill;
  $(module)instance *here;
  $(module)instance *prev = NULL;
  $(module)model **oldmod;
  
  oldmod = model;
  for ( ; *model ; model = &amp;((*model)->$(module)nextModel)) {
      if ((*model)->$(module)modName == modname ||
          (modfast &amp;&amp; *model == modfast))
	  goto delgot;
      oldmod = model;   
  } 
  return(E_NOMOD);
  
  delgot:
    *oldmod = (*model)->$(module)nextModel; /* cut deleted device out of list */
    for (here = (*model)->$(module)instances; here; here = here->$(module)nextInstance)
    {    if(prev) FREE(prev);
         prev = here;
    }
    if(prev) FREE(prev);
    FREE(*model);
    return(OK);
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%smdel.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%smdel.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEdest.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEdest.c.xml,v 1.2 2006/03/05 09:38:41 pnenzi Exp $
  $Log: ngspiceMODULEdest.c.xml,v $
  Revision 1.2  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.1  2006/03/01 14:30:24  pnenzi

  Added mdel, del and dest functions to interface.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="dectype">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:text format="  double "/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:text format="  int "/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  char* "/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;suffix.h&quot;

void $(module)destroy(GENmodel **inModel)

{
  register $(module)model **model = ($(module)model**)inModel;
  register $(module)instance *here;
  $(module)instance *prev = NULL;
  $(module)model *mod = *model;
  $(module)model *oldmod = NULL;
  
  for ( ; mod ; mod = mod->$(module)nextModel ) {
      if (oldmod) FREE(oldmod);
      oldmod = mod;
      prev = ($(module)instance *)NULL;  
      for (here = mod->$(module)instances; here ; here = here->$(module)nextInstance) {
          if(prev) FREE(prev);
	  prev = here;
	  }
          if(prev) FREE(prev);
    } 
    if(oldmod) FREE(oldmod);
    *model = NULL;
  return;
}

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%sdest.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%sdest.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEnoise.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEnoise.c.xml,v 1.1 2007/07/05 09:45:33 r29173 Exp $
  $Log: ngspiceMODULEnoise.c.xml,v $
  Revision 1.1  2007/07/05 09:45:33  r29173
  started noise implementation (added just a template!)

  Revision 1.2  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.1  2006/03/01 14:30:24  pnenzi

  Added mdel, del and dest functions to interface.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.7" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:template match="code">
<admst:variable name="module" select="%(attribute[name='ngspicename']/value)"/>

#include &quot;ngspice.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;iferrmsg.h&quot;
#include &quot;noisedef.h&quot;
#include &quot;suffix.h&quot;

extern void   NevalSrc();
extern double Nintegrate();

static char* $(module)nNames []= {
<admst:text select="contribution[flickernoise='yes']" format="&quot;&quot;,"/>
<admst:text select="contribution[whitenoise='yes']" format="&quot;&quot;,"/>
<admst:text format="&quot;&quot;"/>
};

int
$(module)noise (int mode, int operation, GENmodel *genmodel, CKTcircuit *ckt, Ndata *data, double *OnDens)
{
  $(module)model *firstModel = ($(module)model *) genmodel;
  $(module)model *model;
  $(module)instance *inst;
  for (model=firstModel; model != NULL; model=model-&gt;$(module)nextModel)
  {
    for (inst=model-&gt;$(module)instances; inst != NULL; inst=inst->$(module)nextInstance)
    {
      if (inst-&gt;$(module)owner != ARCHme) continue;
      switch (operation)
      {
        case N_OPEN:
          break;
        case N_CALC:
          switch (mode)
          {
            case N_DENS:
              break;
            case INT_NOIZ:
              break;
          }
          break;
        case N_CLOSE:
          return (OK);
          break;
      }
    }
  }
  return(OK);
}
</admst:template>

<admst:for-each select="/module">
  <admst:open file="%(attribute[name='ngspicename']/value)noise.c">
    <admst:text format="/***\n*** Interface: %(/simulator/package_string)\n"/>
    <admst:text format=" *** created by: %(/simulator/fullname) - %(/simulator/currentdate) ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:message format="%(attribute[name='ngspicename']/value)noise.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULEguesstopology.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULEguesstopology.c.xml,v 1.13 2007/05/11 07:19:58 r29173 Exp $
  $Log: ngspiceMODULEguesstopology.c.xml,v $
  Revision 1.13  2007/05/11 07:19:58  r29173
  added support to 'div' builtin function

  Revision 1.12  2007/05/07 09:01:18  r29173
  traverse blocks named 'noise' or 'initial_step' during guesstopology code creation

  Revision 1.11  2007/05/04 14:48:09  r29173
  fixed implementation of tempate 'fname' (created unvalid C code)

  Revision 1.9  2007/04/26 13:04:34  r29173
  added cases initializeModel, initiliazeInstance (block name used by psp102)

  Revision 1.8  2007/04/24 12:26:36  r29173
  add case 'blockvariable'

  Revision 1.7  2006/03/06 12:51:29  r29173
  added support to 'analog functions'

  Revision 1.6  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.5  2006/03/03 08:41:41  r29173
  add missing xml code (computation of $function)

  Revision 1.4  2006/03/02 08:53:51  r29173
  started implementing of functions $simparam(), $given(), analysis()

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.6" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!-- expression//function: mapping verilog-name == C-name of function -->
<admst:template match="fname">
  <admst:choose>
    <admst:when test="[name='div']"><admst:return name="fname" value="_div1"/></admst:when>
    <admst:when test="[name='abs']"><admst:return name="fname" value="fabs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="fname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="fname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="fname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="fname" value="log"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:when test="[name='\$model']"><admst:return name="fname" value="_modelname"/></admst:when>
    <admst:when test="[name='\$instance']"><admst:return name="fname" value="_instancename"/></admst:when>
    <admst:when test="[name='\$temperature']"><admst:return name="fname" value="_circuit_temp"/></admst:when>
    <admst:otherwise><admst:return name="fname" value="%(name)"/></admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="function">
  <admst:variable name="function" select="%(name)"/>
  <admst:variable name="args" select=""/>
  <admst:for-each select="arguments">
    <admst:variable test="[$args='']" name="args" select="$args,"/>
    <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
    <admst:variable name="args" select="$args%s"/>
  </admst:for-each>
  <admst:choose>
    <admst:when test="[name='\$simparam']">
      <admst:apply-templates select="." match="function:simparam"/>
    </admst:when>
    <admst:when test="[name='analysis']">
      <admst:apply-templates select="." match="function:analysis"/>
    </admst:when>
    <admst:when test="[name='\$given']">
      <admst:for-each select="arguments[position(.)=1]">
        <admst:if test="[datatypename!='variable']">
          <admst:error format="$given: argument is not a variable\n"/>
        </admst:if>
        <admst:if test="[input='no']">
          <admst:value-of select="name"/>
          <admst:error format="$given(%s): argument is not a parameter\n"/>
        </admst:if>
        <admst:choose>
          <admst:when test="[parametertype='model']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="model->%s_Given"/>
          </admst:when>
          <admst:when test="[parametertype='instance']">
            <admst:value-of select="name"/>
            <admst:value-to select="/simulator/tmp" value="here->%s_Given"/>
          </admst:when>
          <admst:otherwise>
            <admst:error format="$given(%s): should not be reached\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="mycode" select=""/>
      <admst:if test="[exists(arguments)]">
        <admst:for-each select="arguments">
          <admst:apply-templates select="." match="subexpression:stringify:noprobe"/>
          <admst:choose>
            <admst:when test="[$mycode='']">
              <admst:variable name="mycode" select="%s"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="mycode" select="$mycode,%s"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:variable name="mycode" select="($mycode)"/>
      </admst:if>
      <admst:variable name="mycode" select="%(fname(.)/[name='fname']/value)$mycode"/>
      <admst:value-to select="/simulator/tmp" value="$mycode"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="evaluatetopology">
  <admst:choose>
    <admst:when test="[datatypename='callfunction']"/>
    <admst:when test="[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="evaluatetopology"/>
      <admst:apply-templates select="while" match="evaluatetopology"/>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:if test="if[nilled(variable[OPdependent='yes'])]">
        <admst:apply-templates select="if" match="evaluatetopology"/>
        <admst:choose>
          <admst:when test="if/math[dependency='constant']">
            <admst:apply-templates select="if" match="expression:stringify:noprobe"/>
            <admst:text format="if\n(%s)\n"/>
            <admst:text format="{\n"/>
            <admst:apply-templates select="then" match="evaluatetopology"/>
            <admst:text format="}\n"/>
            <admst:if test="[exists(else)]">
              <admst:text format="else\n"/>
              <admst:text format="{\n"/>
              <admst:apply-templates select="else" match="evaluatetopology"/>
              <admst:text format="}\n"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="then" match="evaluatetopology"/>
            <admst:apply-templates select="else" match="evaluatetopology"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='contribution']">
      <admst:if test="lhs[discipline/potential=nature]">
        <admst:choose>
          <admst:when test="lhs/branch[grounded='no']">
            <admst:text test="lhs/branch/nnode[location='internal']"
              format="here->%(lhs/branch/nnode/name)Node = here->%(lhs/branch/pnode/name)Node; /* nnode collapsed */ \n"/>
            <admst:text test="lhs/branch/pnode[location='internal']"
              format="here->%(lhs/branch/pnode/name)Node = here->%(lhs/branch/nnode/name)Node; /* pnode collapsed */ \n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="here->%(lhs/branch/pnode/name)Node = 0; /* pnode collapsed to GND */ \n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:variable name="contribution" select="%(.)"/>
      <admst:variable name="psource" select="%(lhs/branch/pnode)"/>
      <admst:variable name="nsource" select="%(lhs/branch/nnode)"/>
      <admst:for-each select="rhs/probe">
        <admst:variable name="pprobe" select="%(branch/pnode)"/>
        <admst:variable name="nprobe" select="%(branch/nnode)"/>
        <admst:choose>
          <admst:when test="$contribution[static='yes']"> <admst:text format="  static_"/> </admst:when>
          <admst:when test="$contribution[dynamic='yes']"> <admst:text format="  dynamic_"/> </admst:when>
          <admst:when test="$contribution[whitenoise='yes']"> <admst:text format="  whitenoise_"/> </admst:when>
          <admst:when test="$contribution[flickernoise='yes']"> <admst:text format="  flickernoise_"/> </admst:when>
        </admst:choose>
        <admst:choose>
          <admst:when test="[($nprobe/grounded='no')and($nsource/grounded='no')]">
            <admst:text format="jacobian4(%($psource/name),%($nsource/name),%($pprobe/name),%($nprobe/name))\n"/>
          </admst:when>
          <admst:when test="[($nprobe/grounded='no')and($nsource/grounded='yes')]">
            <admst:text format="jacobian2p(%($psource/name),%($pprobe/name),%($nprobe/name))\n"/>
          </admst:when>
          <admst:when test="[$nsource/grounded='no']">
            <admst:text format="jacobian2s(%($psource/name),%($nsource/name),%($pprobe/name))\n"/>
          </admst:when>
          <admst:when test="[$nsource/grounded='yes']">
            <admst:text format="jacobian1(%($psource/name),%($pprobe/name))\n"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='assignment']">
      <admst:if test="[(lhs/insource='yes') and (lhs/OPdependent='no')]">
        <admst:apply-templates select="lhs" match="variable:lhs"/>
        <admst:text format="="/>
        <admst:apply-templates select="rhs" match="expression:stringify:noprobe"/>
        <admst:text format="%s;\n"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:apply-templates select="item" match="evaluatetopology"/>
    </admst:when>
    <admst:when test="[datatypename='expression']"/>
    <admst:when test="[datatypename='probe']"/>
    <admst:when test="[datatypename='variable']"/>
    <admst:when test="[datatypename='mapply_unary']"/>
    <admst:when test="[datatypename='mapply_binary']"/>
    <admst:when test="[datatypename='mapply_ternary']"/>
    <admst:when test="[datatypename='function']"/>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): adms element not implemented\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="code">

#include &quot;ngspice.h&quot;
#include &quot;cktdefs.h&quot;
#include &quot;smpdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;const.h&quot;
#include &quot;sperror.h&quot;
#include &quot;ifsim.h&quot;
#include &quot;suffix.h&quot;

#define jacobian(a,b) here-&gt;PTR_J_##a##_##b##_required=1;
#define static_jacobian4(p,q,r,s)  jacobian(p,r) jacobian(p,s) jacobian(q,r) jacobian(q,s)
#define static_jacobian2s(p,q,r)   jacobian(p,r) jacobian(q,r)
#define static_jacobian2p(p,r,s)   jacobian(p,r) jacobian(p,s)
#define static_jacobian1(p,r)      jacobian(p,r)
#define dynamic_jacobian4(p,q,r,s) jacobian(p,r) jacobian(p,s) jacobian(q,r) jacobian(q,s)
#define dynamic_jacobian2s(p,q,r)  jacobian(p,r) jacobian(q,r)
#define dynamic_jacobian2p(p,r,s)  jacobian(p,r) jacobian(p,s)
#define dynamic_jacobian1(p,r)     jacobian(p,r)
#define whitenoise_jacobian4(p,q,r,s)
#define whitenoise_jacobian2s(p,q,r)
#define whitenoise_jacobian2p(p,r,s)
#define whitenoise_jacobian1(p)
#define flickernoise_jacobian4(p,q,r,s)
#define flickernoise_jacobian2s(p,q,r)
#define flickernoise_jacobian2p(p,r,s)
#define flickernoise_jacobian1(p)


int $(module)guesstopology (SMPmatrix *matrix, CKTcircuit *ckt, $(module)model *model, $(module)instance *here)
     /* guess topology */
{
<admst:template match="evaluate.localvariables">
  <admst:choose>
    <admst:when test="[datatypename='assignment']">
      <admst:if test="[(lhs/insource='yes') and (lhs/OPdependent='no')]">
        <admst:push select="lhs[scope='local']" into="$localvariables" onduplicate="ignore"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:apply-templates select="item" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:push select="if/variable[scope='local' and OPdependent='no']" into="$localvariables" onduplicate="ignore"/>
      <admst:apply-templates select="then" match="evaluate.localvariables"/>
      <admst:apply-templates select="else" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='case']">
      <admst:apply-templates select="caseitem/code" match="evaluate.localvariables"/>
    </admst:when>
    <admst:when test="[datatypename='contribution']"/>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='callfunction']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:error format="'%(datatypename): should not be reached\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
  <admst:for-each select="analog/code[datatypename='block']/item">
    <admst:if test="[(datatypename!='block') or (datatypename='block'
         and name!='initial_model' and name!='initializeModel' and name!='initial_instance' and name!='initializeInstance')]">
      <admst:apply-templates select="." match="evaluate.localvariables"/>
    </admst:if>
  </admst:for-each>
  <admst:for-each select="$localvariables">
    <admst:if test="[type='integer']">int %(name);\n</admst:if>
    <admst:if test="[type='real']">double %(name)=0.0/0.0;\n</admst:if>
    <admst:if test="[type='string']">char* %(name);\n</admst:if>
  </admst:for-each>
  <admst:for-each select="analog/code[datatypename='block']/item">
    <admst:if test="[(datatypename!='block') or (datatypename='block'
         and name!='initial_model' and name!='initializeModel' and name!='initial_instance' and name!='initializeInstance')]">
      <admst:apply-templates select="." match="evaluatetopology"/>
    </admst:if>
  </admst:for-each>
  return(OK);
}

</admst:template>

<admst:variable name="localvariables"/>
<admst:for-each select="/module">
  <admst:variable name="module" select="%(attribute[name='ngspicename']/value)"/>
  <admst:open file="$(module)guesstopology.c">
    <admst:text format="/***\n*** Interface: %(/simulator/package_string)\n"/>
    <admst:text format=" *** created by: %(/simulator/fullname) - %(/simulator/currentdate) ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:message format="$(module)guesstopology.c: file created\n"/>
</admst:for-each>

</admst>

<?escript name="../admst/ngspiceMODULE.hxx.xml" ?>

<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.2" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<admst:variable name="pprobe"/>
<admst:variable name="qprobe"/>
<admst:variable name="e"/>
<admst:variable name="ep"/>
<admst:variable name="eq"/>
<admst:variable name="epq"/>

<admst:template match="c:math_h">
/* arithmetics */
#define EXP90 1.220403294317841e+039
#define m00_hypot(v00,x,y)      v00 = sqrt((x)*(x)+(y)*(y));
#define m10_hypot(v10,v00,x,y)  v10 = (x)/(v00);
#define m11_hypot(v11,v00,x,y)  v11 = (y)/(v00);
#define m00_max(v00,x,y)        v00 = ((x)&gt;(y))?(x):(y);
#define m10_max(v10,v00,x,y)    v10 = ((x)&gt;(y))?1.0:0.0;
#define m11_max(v11,v00,x,y)    v11 = ((x)&gt;(y))?0.0:1.0;
#define m00_min(v00,x,y)        v00 = ((x)&lt;(y))?(x):(y);
#define m10_min(v10,v00,x,y)    v10 = ((x)&lt;(y))?1.0:0.0;
#define m11_min(v11,v00,x,y)    v11 = ((x)&lt;(y))?0.0:1.0;
#define m00_pow(v00,x,y)        v00 = pow(x,y);
#define m10_pow(v10,v00,x,y)    v10 = (x==0.0)?0.0:(v00)*(y)/(x);
#define m11_pow(v11,v00,x,y)    v11 = (x==0.0)?0.0:(log(x)*(v00));
#define m00_div(v00,v10,x,y)    double v10=1/(y); double v00=(x)*v10;
#define m10_div(v10,v00,vv,x,y)
#define m11_div(v11,v00,vv,x,y) double v11 = -v00*vv;
#define m00_mult(v00,v10,v11,x,y) double v10=(x); double v11=(y); double v00=v10*v11;
#define m00_add(v00,x,y)        double v00=(x)+(y);
#define m00_cos(v00,x)          v00 = cos(x);
#define m10_cos(v10,v00,x)      v10 = (-sin(x));
#define m00_sin(v00,x)          v00 = sin(x);
#define m10_sin(v10,v00,x)      v10 = (cos(x));
#define m00_tan(v00,x)          v00 = tan(x);
#define m10_tan(v10,v00,x)      v10 = (1.0/cos(x)/cos(x));
#define m00_cosh(v00,x)         v00 = cosh(x);
#define m10_cosh(v10,v00,x)     v10 = (sinh(x));
#define m00_sinh(v00,x)         v00 = sinh(x);
#define m10_sinh(v10,v00,x)     v10 = (cosh(x));
#define m00_tanh(v00,x)         v00 = tanh(x);
#define m10_tanh(v10,v00,x)     v10 = (1.0/cosh(x)/cosh(x));
#define m00_acos(v00,x)         v00 = acos(x);
#define m10_acos(v10,v00,x)     v10 = (-1.0/sqrt(1-x*x));
#define m00_asin(v00,x)         v00 = asin(x);
#define m10_asin(v10,v00,x)     v10 = (+1.0/sqrt(1-x*x));
#define m00_atan(v00,x)         v00 = atan(x);
#define m10_atan(v10,v00,x)     v10 = (+1.0/(1+x*x));
#define m00_logE(v00,x)         v00 = log(x);
#define m10_logE(v10,v00,x)     v10 = (1.0/x);
#define m00_log10(v00,x)        v00 = log10(x);
#define m10_log10(v10,v00,x)    v10 = (1.0/x/log(10));
#define m00_sqrt(v00,x)         v00 = sqrt(x);
#define m10_sqrt(v10,v00,x)     v10 = (0.5/v00);
#define m00_fabs(v00,x)         v00 = fabs(x);
#define m10_fabs(v10,v00,x)     v10 = (((x)&gt;=0)?(+1.0):(-1.0));
#define m00_exp(v00,x)          v00 = exp(x);
#define m10_exp(v10,v00,x)      v10 = v00;
#define m00_abs(v00)            ((v00)&lt;(0)?(-(v00)):(v00))
#define m00_limexp(v00,x)       v00 = ((x)&lt;90.0?exp(x):EXP90*(x-89.0));
#define m10_limexp(v10,v00,x)   v10 = ((x)&lt;90.0?(v00):EXP90);

#define m20_logE(v00)         (-1.0/v00/v00)
#define m20_exp(v00)          exp(v00)
#define m20_limexp(v00)       ((v00)&lt;90.0?exp(v00):0.0)
#define m20_sqrt(v00)         (-0.25/(v00)/sqrt(v00))
#define m20_fabs(v00)         0.0

</admst:template>

<admst:template match="wrapper">
/*wrapper*/
#define pModel model
#define pInst here
#define mint_get_circuit_tempK() _circuit_temp
#define voltages(n) NP(n)
#define _DDT(q) q
#define _DDX
#define _DERIVATEFORDDX
<admst:if test="/module/variable[derivate='yes' and insource='yes']">
#define _DERIVATE2
<admst:variable name="requiredderivateforddx" select="yes"/>
</admst:if>
</admst:template>

<admst:template match="c:analogfunction:math_h">
inline double _cos(double arg)             { return  cos(arg); }
inline double _d0_cos(double arg)          { return (-sin(arg)); }
inline double _sin(double arg)             { return  sin(arg); }
inline double _d0_sin(double arg)          { return (cos(arg)); }
inline double _tan(double arg)             { return  tan(arg); }
inline double _d0_tan(double arg)          { return (1.0/cos(arg)/cos(arg)); }
inline double _cosh(double arg)            { return  cosh(arg); }
inline double _d0_cosh(double arg)         { return (sinh(arg)); }
inline double _sinh(double arg)            { return  sinh(arg); }
inline double _d0_sinh(double arg)         { return (cosh(arg)); }
inline double _tanh(double arg)            { return  tanh(arg); }
inline double _d0_tanh(double arg)         { return (1.0/cosh(arg)/cosh(arg)); }
inline double _acos(double arg)            { return  acos(arg); }
inline double _d0_acos(double arg)         { return (-1.0/sqrt(1-arg*arg)); }
inline double _asin(double arg)            { return  asin(arg); }
inline double _d0_asin(double arg)         { return (+1.0/sqrt(1-arg*arg)); }
inline double _atan(double arg)            { return  atan(arg); }
inline double _d0_atan(double arg)         { return (+1.0/(1+arg*arg)); }
inline double _logE(double arg)            { return  log(arg); }
inline double _d0_logE(double arg)         { return (1.0/arg); }
inline double _log10(double arg)           { return  log10(arg); }
inline double _d0_log10(double arg)        { return (1.0/arg/log(10)); }
inline double _exp(double arg)             { return  exp(arg); }
inline double _d0_exp(double arg)          { return exp(arg); }
inline double _sqrt(double arg)            { return  sqrt(arg); }
inline double _d0_sqrt(double arg)         { return (1.0/sqrt(arg)/2.0); }
inline double _abs(double arg)             { return  fabs(arg); }
inline double _d0_abs(double arg)          { return (((arg)&gt;=0)?(+1.0):(-1.0)); }

inline double _hypot(double x,double y)    { return sqrt((x)*(x)+(y)*(y)); }
inline double _d0_hypot(double x,double y) { return (x)/sqrt((x)*(x)+(y)*(y)); }
inline double _d1_hypot(double x,double y) { return (y)/sqrt((x)*(x)+(y)*(y)); }

inline double _max(double x,double y)      { return ((x)&gt;(y))?(x):(y); }
inline double _d0_max(double x,double y)   { return ((x)&gt;(y))?1.0:0.0; }
inline double _d1_max(double x,double y)   { return ((x)&gt;(y))?0.0:1.0; }

inline double _min(double x,double y)      { return ((x)&lt;(y))?(x):(y); }
inline double _d0_min(double x,double y)   { return ((x)&lt;(y))?1.0:0.0; }
inline double _d1_min(double x,double y)   { return ((x)&lt;(y))?0.0:1.0; }

inline double _pow(double x,double y)      { return pow(x,y); }
inline double _d0_pow(double x,double y)   { return (x==0.0)?0.0:((y/x)*pow(x,y)); }
inline double _d1_pow(double x,double y)   { return (x==0.0)?0.0:((log(x)/exp(0.0))*pow(x,y)); }

#define _limexp(arg)    _exp(val,arg)
#define _d_limexp(arg)  _d_exp(val,dval,arg)

</admst:template>


<!-- compute node arguments of noise routines -->
<admst:template match="noisebranch">
  <admst:variable name="n1" select=""/>
  <admst:choose>
    <admst:when test="lhs[grounded='yes']">
      <admst:return name="noisebranch" value="%(lhs/branch/pnode/name),%(lhs/branch/pnode/name)"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="noisebranch" value="%(lhs/branch/pnode/name),%(lhs/branch/nnode/name)"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- compute range of variables -->
<admst:template match="variable:range:foreach">
  <admst:choose>
    <admst:when test="infexpr[hasspecialnumber='NO']">
      <admst:apply-templates select="infexpr/tree" match="%(adms/datatypename)"/>
      <admst:variable name="lower" select="$e"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="lower" select="-inf"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="supexpr[hasspecialnumber='NO']">
      <admst:apply-templates select="supexpr/tree" match="%(adms/datatypename)"/>
      <admst:variable name="upper" select="$e"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="upper" select="inf"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="[type='include']">
      <admst:variable name="rangetype" select="from"/>
    </admst:when>
    <admst:when test="[type='exclude']">
      <admst:variable name="rangetype" select="exclude"/>
    </admst:when>
  </admst:choose>
  <admst:variable name="interval" select="$lower:$upper"/>
  <admst:choose>
    <admst:when test="[infboundtype='range_bound_include' and supboundtype='range_bound_include']">
      <admst:variable name="interval" select="[$interval]"/>
    </admst:when>
    <admst:when test="[infboundtype='range_bound_include' and supboundtype='range_bound_exclude']">
      <admst:variable name="interval" select="[$interval)"/>
    </admst:when>
    <admst:when test="[infboundtype='range_bound_exclude' and supboundtype='range_bound_include']">
      <admst:variable name="interval" select="($interval]"/>
    </admst:when>
    <admst:when test="[infboundtype='range_bound_exclude' and supboundtype='range_bound_exclude']">
      <admst:variable name="interval" select="($interval)"/>
    </admst:when>
  </admst:choose>
  <admst:text format="$rangetype $interval "/>
</admst:template>
<admst:template match="variable:range">
  <admst:choose>
    <admst:when test="range">
      <admst:text format="        &quot;"/>
      <admst:apply-templates select="range" match="variable:range:foreach"/>
      <admst:text format="&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="        NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- expression//function: mapping verilog-name == C-name of function -->
<admst:template match="function:getname">
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="function:getname" value="abs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="function:getname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="function:getname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="function:getname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="function:getname" value="logE"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="function:getname" value="limexp"/></admst:when>
    <admst:when test="[name='\$model']"><admst:return name="function:getname" value="_modelname"/></admst:when>
    <admst:when test="[name='\$instance']"><admst:return name="function:getname" value="_instancename"/></admst:when>
    <admst:when test="[name='\$temperature']"><admst:return name="function:getname" value="_circuit_temp"/></admst:when>
    <admst:when test="[name='\$nominal_temperature']"><admst:return name="function:getname" value="_circuit_tnom"/></admst:when>
    <admst:otherwise><admst:value-of select="name"/><admst:return name="function:getname" value="%s"/></admst:otherwise>
  </admst:choose>
</admst:template>
<admst:template match="af:print:expression">
  <admst:choose>
    <admst:when test="adms[datatypename='expression']">
      <admst:apply-templates select="tree" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="expression" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:return name="x" value="$expression"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="$(dx_%s)"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='probe']">
      <admst:fatal format="probe not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='variable']">
      <admst:value-of select="name"/>
      <admst:variable name="variable" select="%s"/>
      <admst:return name="x" value="$variable"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:variable name="ddx" select="%s"/>
        <admst:choose>
          <admst:when test="[$variable='$ddx']">
            <admst:return name="dx.$ddx" value="1.0"/>
          </admst:when>
          <admst:when test="../..[input='yes']">
            <admst:return name="dx.$ddx" value="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:return name="dx.$ddx" value="$(variable)_$ddx"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_unary']">
      <admst:if test="[name='plus']">
        <admst:variable name="op" select="+"/>
      </admst:if>
      <admst:if test="[name='minus']">
        <admst:variable name="op" select="-"/>
      </admst:if>
      <admst:if test="[name='not']">
        <admst:variable name="op" select="!"/>
      </admst:if>
      <admst:if test="[name='bw_not']">
        <admst:variable name="op" select="~"/>
      </admst:if>
      <admst:apply-templates select="arg1" match="af:print:expression"><admst:value-of select="returned('x')/value"/><admst:variable name="arg1" select="%s"/></admst:apply-templates>
      <admst:return name="x" value="($op$arg1)"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dx_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="dy_%s" select="%s"/>
        </admst:for-each>
      </admst:apply-templates>
      <admst:choose>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(+$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x+$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(+$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx+$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="(-$y)"/>
            </admst:when>
            <admst:when test="[$y='0.0']">
              <admst:return name="x" value="$x"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x-$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="(-$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="($dx-$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:choose>
            <admst:when test="[$x='0.0' or $y='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x*$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0' or $y='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$df)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x)"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="($y)"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:return name="dx.$df" value="($x*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:return name="dx.$df" value="$dx*$y"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='1.0']">
                <admst:return name="dx.$df" value="($x+$y)"/>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:return name="dx.$df" value="($y+($dy*$x))"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:return name="dx.$df" value="($dx*$y)+$x"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:return name="dx.$df" value="$dy"/>
              </admst:when>
              <admst:when test="[$y='1.0']">
                <admst:return name="dx.$df" value="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="dx.$df" value="(($dx*$y)+($x*$dy))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:choose>
            <admst:when test="[$x='0.0']">
              <admst:return name="x" value="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0' and $y='1.0']">
              <admst:return name="x" value="1.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="x" value="($x/$y)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/><admst:variable name="df" select="%s"/>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:variable name="dx" select="0.0"/>
                <admst:variable name="dy" select="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="dx" select="$(dx_$df)"/>
                <admst:variable name="dy" select="$(dy_$(df))"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:return name="dx.$df" value="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-1/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-$dy/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(-$x/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(-($x*$dy)/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="(1/$y)"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($y-$x)/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="(($y-($x*$dy))/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$y='1.0']">
                    <admst:return name="dx.$df" value="$dx"/>
                  </admst:when>
                  <admst:when test="[$dy='0.0']">
                    <admst:return name="dx.$df" value="$dx/$y"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:return name="dx.$df" value="(($dx*$y)-$x)/($y*$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:return name="dx.$df" value="($dx*$y-$x*$dy)/($y*$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[name='bw_equr']">
              <admst:return name="x" value="($x^~$y)"/>
            </admst:when>
            <admst:when test="[name='bw_equl']">
              <admst:return name="x" value="($x~^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_xor']">
              <admst:return name="x" value="($x^$y)"/>
            </admst:when>
            <admst:when test="[name='bw_or']">
              <admst:return name="x" value="($x|$y)"/>
            </admst:when>
            <admst:when test="[name='bw_and']">
              <admst:return name="x" value="($x&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='or']">
              <admst:return name="x" value="($x||$y)"/>
            </admst:when>
            <admst:when test="[name='and']">
              <admst:return name="x" value="($x&amp;&amp;$y)"/>
            </admst:when>
            <admst:when test="[name='equ']">
              <admst:return name="x" value="($x==$y)"/>
            </admst:when>
            <admst:when test="[name='multmod']">
              <admst:return name="x" value="((int)$x%%(int)$y)"/>
            </admst:when>
            <admst:when test="[name='notequ']">
              <admst:return name="x" value="($x!=$y)"/>
            </admst:when>
            <admst:when test="[name='lt']">
              <admst:return name="x" value="($x&lt;$y)"/>
            </admst:when>
            <admst:when test="[name='lt_equ']">
              <admst:return name="x" value="($x&lt;=$y)"/>
            </admst:when>
            <admst:when test="[name='gt']">
              <admst:return name="x" value="($x&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='gt_equ']">
              <admst:return name="x" value="($x&gt;=$y)"/>
            </admst:when>
            <admst:when test="[name='shiftr']">
              <admst:return name="x" value="($x&gt;&gt;$y)"/>
            </admst:when>
            <admst:when test="[name='shiftl']">
              <admst:return name="x" value="($x&lt;&lt;$y)"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-of select="name"/>
              <admst:error format="%s: function not handled\n"/>
            </admst:otherwise>
          </admst:choose>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:return name="dx.%s" value="0.0"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="x" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg2" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="y" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="arg3" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="z" select="%s"/>
      </admst:apply-templates>
      <admst:if test="[name='conditional']">
        <admst:return name="x" value="($x?$y:$z)"/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:value-of select="name"/>
          <admst:return name="dx.%s" value="($x?$dy_%s:$dz_%s)"/>
        </admst:for-each>
      </admst:if>
    </admst:when>
    <admst:when test="adms[datatypename='function']">
      <admst:apply-templates select="." match="function:getname">
        <admst:value-of select="returned('function:getname')/value"/>
        <admst:variable name="function" select="%s"/>
      </admst:apply-templates>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[not($args='')]">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args%s"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/>
            <admst:value-of select="returned('dx.%s')/value"/>
            <admst:value-of select="name"/>
            <admst:variable name="arg$(index)_%s" select="%s"/>
          </admst:for-each>
        </admst:apply-templates>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[ name='cos' or name='sin' or name='tan' or name='cosh' or name='sinh' or name='tanh' or name='acos' or name='asin'
                            or name='atan' or name='ln' or name='log' or name='exp' or name='sqrt' or name='abs' or name='limexp'
                            or name='div' or name='pow' or name='hypot' or name='min' or name='max' ]">
          <admst:return name="x" value="_$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/> <admst:variable name="name" select="%s"/>
            <admst:variable name="ret" select=""/>
            <admst:for-each select="../../arguments">
              <admst:if test="[not($ret='')]">
                <admst:variable name="ret" select="$ret+"/>
              </admst:if>
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="ret" select="$(ret)_d$(index)_$function($args)*($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="$ret"/>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:return name="x" value="$function($args)"/>
          <admst:for-each select="$globalanalogfunction/variable[input='yes']">
            <admst:value-of select="name"/> <admst:variable name="name" select="%s"/>
            <admst:variable name="darg" select=""/>
            <admst:for-each select="../../arguments">
              <admst:value-of select="index(../arguments,.)"/>
              <admst:variable name="index" select="%s"/>
              <admst:variable name="darg" select="$darg,($(arg$(index)_$name))"/>
            </admst:for-each>
            <admst:return name="dx.$name" value="d_$function($args$darg)"/>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="adms[datatypename='string']">
      <admst:value-of select="value"/>
      <admst:return name="x" value="&quot;%s&quot;"/>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="adms[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="%s"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+18)"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+15)"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+12)"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+9)"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+6)"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+3)"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+2)"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e+1)"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-1)"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-2)"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-3)"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-6)"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-9)"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-10)"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-12)"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-15)"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:value-of select="value"/>
          <admst:return name="x" value="(%s*1.0e-18)"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-of select="scalingunit"/>
          <admst:fatal format="scaling unit not supported: %s\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:for-each select="$globalanalogfunction/variable[input='yes']">
        <admst:value-of select="name"/>
        <admst:return name="dx.%s" value="0.0"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<admst:template match="af:print:derivate">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args,%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print:derivate">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="then" select="$(then)else\n%s"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" value="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="$condition case %s:"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:value-of select="lhs/name"/>
      <admst:variable name="lhs" select="%s"/>
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:variable name="rhs" select=""/>
        <admst:for-each select="$globalanalogfunction/variable[input='yes']">
          <admst:value-of select="name"/>
          <admst:value-of select="returned('dx.%s')/value"/>
          <admst:value-of select="name"/>
          <admst:variable name="rhs" select="$rhs$(lhs)_%s=%s;\n"/>
        </admst:for-each>
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="rhs" select="$rhs$lhs=%s;\n"/>
      </admst:apply-templates>
      <admst:return name="x" value="{$rhs}\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print:derivate">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="{$block}"/>
    </admst:when>
    <admst:otherwise>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<admst:template match="af:print">
  <admst:choose>
    <admst:when test="adms[datatypename='callfunction']">
      <admst:choose>
        <admst:when test="function[name='\$strobe']">
          <admst:variable name="outputfile" select="stdout"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="args" select=""/>
      <admst:for-each select="function/arguments">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:value-of select="index(../arguments,.)"/>
          <admst:variable name="index" select="%s"/>
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="args" select="$args,%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="whileblock" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="while" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="while" select="%s"/>
      </admst:apply-templates>
      <admst:return name="x" value="while($whileblock)\n$while"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="if" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="if" select="%s"/>
      </admst:apply-templates>
      <admst:apply-templates select="then" match="af:print">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="then" select="%s"/>
        </admst:apply-templates>
      <admst:if test="else">
        <admst:apply-templates select="else" match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="then" select="$(then)else\n%s"/>
        </admst:apply-templates>
      </admst:if>
      <admst:return name="x" value="if($if)\n$then"/>
    </admst:when>
    <admst:when test="adms[datatypename='case']">
      <admst:apply-templates select="case" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:variable name="case" select="switch ((int)%s) {\n"/>
      </admst:apply-templates>
      <admst:for-each select="caseitem">
        <admst:variable name="condition" select=""/>
        <admst:for-each select="condition">
          <admst:value-of select="."/>
          <admst:variable name="condition" select="$condition case %s:"/>
        </admst:for-each>
        <admst:variable name="case" select="$case $condition"/>
        <admst:if test="[defaultcase='yes']">
          <admst:variable name="case" select="$case default:"/>
        </admst:if>
        <admst:variable name="case" select="$case \n"/>
        <admst:apply-templates select="code" match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="case" select="$case%s break;\n"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="$case }"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']">
      <admst:fatal format="contribution not allowed inside analog functions\n"/>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="af:print:expression">
        <admst:value-of select="returned('x')/value"/>
        <admst:value-of select="../lhs/name"/>
        <admst:return name="x" value="%s=%s;\n"/>
      </admst:apply-templates>
    </admst:when>
    <admst:when test="adms[datatypename='nilled']">
      <admst:return name="x" value=";"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:variable name="block" select=""/>
      <admst:for-each select="item">
        <admst:apply-templates select="." match="af:print">
          <admst:value-of select="returned('x')/value"/>
          <admst:variable name="block" select="$block%s"/>
        </admst:apply-templates>
      </admst:for-each>
      <admst:return name="x" value="{$block}"/>
    </admst:when>
    <admst:otherwise>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* Returns the type of a variable. The returned type
* is either int, double, or char *. This template is
* used to create the mint:instance and model data structures.
-->
<admst:template match="vtype">
  <admst:choose>
    <admst:when test="[type='integer']">int</admst:when>
    <admst:when test="[type='real']">double</admst:when>
    <admst:when test="[type='string']">char*</admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="bname">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" value="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" value="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" value="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" value="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" value="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" value="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" value="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" value="=="/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" value="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" value="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" value="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" value="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" value="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" value="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" value="&lt;&lt;"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- expression//function: get function name -->
<admst:template match="funcname">
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="fname" value="fabs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="fname" value="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="fname" value="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="fname" value="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="fname" value="logE"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="fname" value="limexp"/></admst:when>
    <admst:otherwise><admst:return name="fname" value="%(name)"/></admst:otherwise>
  </admst:choose>
</admst:template>
<admst:template match="fname">
  <admst:choose>
    <admst:when test="[name='abs']">fabs</admst:when>
    <admst:when test="[name='\$shrinkl']">shrinkl</admst:when>
    <admst:when test="[name='\$shrinka']">shrinka</admst:when>
    <admst:when test="[name='log']">log10</admst:when>
    <admst:when test="[name='ln']">logE</admst:when>
    <admst:when test="[name='limexp']">limexp</admst:when>
    <admst:when test="[name='\$limexp']">limexp</admst:when>
    <admst:otherwise>%(name)</admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="e">
  <admst:apply-templates select="." match="%(adms/datatypename)">$e</admst:apply-templates>
</admst:template>
<admst:template match="ddx">
  <admst:apply-templates select="." match="%(adms/datatypename)"/>
</admst:template>
<admst:template match="ddxname">
  <admst:return name="ddxname" value="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
</admst:template>
<admst:template match="dxname">
  <admst:return name="dxname" value="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
</admst:template>
<admst:template match="variable">
  <admst:choose>
    <admst:when test="[input='yes' and parametertype='model']">
      <admst:variable name="e" select="pModel-&gt;%(name)"/>
    </admst:when>
    <admst:when test="[input='yes' and parametertype='instance']">
      <admst:variable name="e" select="pInst-&gt;%(name)"/>
    </admst:when>
    <admst:when test="[input='no' and scope='global_model']">
      <admst:variable name="e" select="pModel-&gt;%(name)"/>
    </admst:when>
    <admst:when test="[input='no' and scope='global_instance']">
      <admst:variable name="e" select="pInst-&gt;%(name)"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="%(name)"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" select="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:variable name="ep" select="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$qprobe" list="%(probe)">
      <admst:variable name="eq" select="%(name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>

  <admst:variable name="epq" select="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:if-inside select="$qprobe" list="%(probe)">
        <admst:variable name="epq" select="%(ddxname(.)/[name='ddxname']/value)"/>
      </admst:if-inside>
    </admst:if-inside>
  </admst:if>
  </admst:if>
</admst:template>

<admst:template match="probe">
  <admst:choose>
    <admst:when test="branch/nnode[grounded='no']">
      <admst:variable name="e" select="(NP(%(branch/pnode/name))-NP(%(branch/nnode/name)))"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="NP(%(branch/pnode/name))"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[.=$pprobe]">
      <admst:variable name="ep" select="1.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" select="0.0"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:choose>
    <admst:when test="[.=$qprobe]">
      <admst:variable name="eq" select="1.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="eq" select="0.0"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>

<admst:template match="node">
  <admst:fatal format="module node not expected here ... %(name)\n"/>

  <admst:fatal format="module node not expected here ... %(name)\n"/>
  <admst:if test="$qprobe">

  <admst:fatal format="module node not expected here ... %(name)\n"/>
  </admst:if>
</admst:template>

<admst:template match="string">
  <admst:variable name="e" select="&quot;%(value)&quot;"/>

  <admst:variable name="ep" select="0.0"/>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>

<admst:template match="number">
  <admst:choose>
    <admst:when test="[scalingunit='1']">
      <admst:variable name="e" select="%(value)"/>
    </admst:when>
    <admst:when test="[scalingunit='E']">
      <admst:variable name="e" select="(%(value)*1.0e+18)"/>
    </admst:when>
    <admst:when test="[scalingunit='P']">
      <admst:variable name="e" select="(%(value)*1.0e+15)"/>
    </admst:when>
    <admst:when test="[scalingunit='T']">
      <admst:variable name="e" select="(%(value)*1.0e+12)"/>
    </admst:when>
    <admst:when test="[scalingunit='G']">
      <admst:variable name="e" select="(%(value)*1.0e+9)"/>
    </admst:when>
    <admst:when test="[scalingunit='M']">
      <admst:variable name="e" select="(%(value)*1.0e+6)"/>
    </admst:when>
    <admst:when test="[scalingunit='k']">
      <admst:variable name="e" select="(%(value)*1.0e+3)"/>
    </admst:when>
    <admst:when test="[scalingunit='h']">
      <admst:variable name="e" select="(%(value)*1.0e+2)"/>
    </admst:when>
    <admst:when test="[scalingunit='D']">
      <admst:variable name="e" select="(%(value)*1.0e+1)"/>
    </admst:when>
    <admst:when test="[scalingunit='d']">
      <admst:variable name="e" select="(%(value)*1.0e-1)"/>
    </admst:when>
    <admst:when test="[scalingunit='c']">
      <admst:variable name="e" select="(%(value)*1.0e-2)"/>
    </admst:when>
    <admst:when test="[scalingunit='m']">
      <admst:variable name="e" select="(%(value)*1.0e-3)"/>
    </admst:when>
    <admst:when test="[scalingunit='u']">
      <admst:variable name="e" select="(%(value)*1.0e-6)"/>
    </admst:when>
    <admst:when test="[scalingunit='n']">
      <admst:variable name="e" select="(%(value)*1.0e-9)"/>
    </admst:when>
    <admst:when test="[scalingunit='A']">
      <admst:variable name="e" select="(%(value)*1.0e-10)"/>
    </admst:when>
    <admst:when test="[scalingunit='p']">
      <admst:variable name="e" select="(%(value)*1.0e-12)"/>
    </admst:when>
    <admst:when test="[scalingunit='f']">
      <admst:variable name="e" select="(%(value)*1.0e-15)"/>
    </admst:when>
    <admst:when test="[scalingunit='a']">
      <admst:variable name="e" select="(%(value)*1.0e-18)"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="scaling unit not supported: %(scalingunit)\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" select="0.0"/>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>

<admst:template match="mapply_unary">
  <admst:choose>
    <admst:when test="[name='plus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(+$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='minus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(-$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(!$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='bw_not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(~$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(name): function not handled\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[$e='0.0']">
      <admst:variable name="ep" select="0.0"/>
    </admst:when>
    <admst:when test="[$ep='0.0']">
      <admst:variable name="ep" select="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:variable name="ep" select="(+$ep)"/>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:variable name="ep" select="(-$ep)"/>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:variable name="ep" select="(!$ep)"/>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:variable name="ep" select="(~$ep)"/>
        </admst:when>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:choose>
    <admst:when test="[$e='0.0']">
      <admst:variable name="eq" select="0.0"/>
    </admst:when>
    <admst:when test="[$eq='0.0']">
      <admst:variable name="eq" select="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:variable name="eq" select="(+$eq)"/>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:variable name="eq" select="(-$eq)"/>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:variable name="eq" select="(!$eq)"/>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:variable name="eq" select="(~$eq)"/>
        </admst:when>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="epq" select="0.0"/>
  </admst:if>
</admst:template>

<admst:template match="mapply_binary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" select="$e"/>
  <admst:variable name="xp" select="$ep"/>
  <admst:variable name="xq" select="$eq"/>
  <admst:variable name="xpq" select="$epq"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" select="$e"/>
  <admst:variable name="yp" select="$ep"/>
  <admst:variable name="yq" select="$eq"/>
  <admst:variable name="ypq" select="$epq"/>
  <admst:choose>
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(+$y)"/>
          <admst:variable name="xp" select="0.0"/>
        </admst:when>
        <admst:when test="[arg2/math/value=0.0]">
          <admst:variable name="e" select="%($x)"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x+$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(-$y)"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="$ep"/>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:variable name="e" select="$x"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x-$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x*$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="0.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" select="0.0"/>
          <admst:variable name="y" select="0.0"/>
          <admst:variable name="xp" select="0.0"/>
          <admst:variable name="yp" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x/$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="($x%(bname(.)/[name='bname']/value)$y)"/>
    </admst:otherwise>
  </admst:choose>

    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="$yp"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" select="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="($xp+$yp)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="(-$yp)"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" select="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="($xp-$yp)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='1.0']">
            <admst:variable name="ep" select="($x)"/>
          </admst:when>
          <admst:when test="[$xp='1.0' and $yp='0.0']">
            <admst:variable name="ep" select="($y)"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="($x*$yp)"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" select="$xp*$y"/>
          </admst:when>
          <admst:when test="[$xp='1.0' and $yp='1.0']">
            <admst:variable name="ep" select="($x+$y)"/>
          </admst:when>
          <admst:when test="[$xp='1.0']">
            <admst:variable name="ep" select="($y+($yp*$x))"/>
          </admst:when>
          <admst:when test="[$yp='1.0']">
            <admst:variable name="ep" select="(($xp*$y)+$x)"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:variable name="ep" select="$yp"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:variable name="ep" select="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="(($xp*$y)+($x*$yp))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" select="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(-1/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(-$yp/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:choose>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(-$x/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(-$x*$yp/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xp='1.0']">
            <admst:choose>
              <admst:when test="[$yp='0.0']">
                <admst:variable name="ep" select="(1/$y)"/>
              </admst:when>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(($y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(($y-($x*$yp))/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:variable name="ep" select="$xp"/>
              </admst:when>
              <admst:when test="[$yp='0.0']">
                <admst:variable name="ep" select="($xp/$y)"/>
              </admst:when>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(($xp*$y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(($xp*$y-$x*$yp)/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="ep" select="0.0"/>
      </admst:otherwise>
    </admst:choose>
  <admst:if test="$qprobe">

    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="$yq"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" select="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="($xq+$yq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="(-$yq)"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" select="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="($xq-$yq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='1.0']">
            <admst:variable name="eq" select="($x)"/>
          </admst:when>
          <admst:when test="[$xq='1.0' and $yq='0.0']">
            <admst:variable name="eq" select="($y)"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="($x*$yq)"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" select="$xq*$y"/>
          </admst:when>
          <admst:when test="[$xq='1.0' and $yq='1.0']">
            <admst:variable name="eq" select="($x+$y)"/>
          </admst:when>
          <admst:when test="[$xq='1.0']">
            <admst:variable name="eq" select="($y+($yq*$x))"/>
          </admst:when>
          <admst:when test="[$yq='1.0']">
            <admst:variable name="eq" select="(($xq*$y)+$x)"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:variable name="eq" select="$yq"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:variable name="eq" select="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="(($xq*$y)+($x*$yq))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" select="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(-1/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(-$yq/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:choose>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(-$x/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(-$x*$yq/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xq='1.0']">
            <admst:choose>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" select="(1/$y)"/>
              </admst:when>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(($y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(($y-($x*$yq))/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:variable name="eq" select="$xq"/>
              </admst:when>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" select="($xq/$y)"/>
              </admst:when>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(($xq*$y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(($xq*$y-$x*$yq)/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="eq" select="0.0"/>
      </admst:otherwise>
    </admst:choose>

    <admst:choose>
      <admst:when test="[name='addp']">
          <admst:variable name="t1" select="+$xpq"/>
          <admst:variable name="t2" select="+$ypq"/>
          <admst:variable name="epq" select="$t1$t2"/>
          <admst:choose>
            <admst:when test="[$epq='']">
              <admst:variable name="epq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="epq" select="($epq)"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
          <admst:variable name="t1" select="+$xpq"/>
          <admst:variable name="t2" select="-$ypq"/>
          <admst:variable name="epq" select="$t1$t2"/>
          <admst:choose>
            <admst:when test="[$epq='']">
              <admst:variable name="epq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="epq" select="($epq)"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
          <admst:variable name="t1" select="+$xpq*$y"/>
          <admst:variable name="t2" select="+$xp*$yq"/>
          <admst:variable name="t3" select="+$xq*$yp"/>
          <admst:variable name="t4" select="+$x*$ypq"/>
          <admst:variable name="epq" select="$t1$t2$t3$t4"/>
          <admst:choose>
            <admst:when test="[$eq='']">
              <admst:variable name="eq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="eq" select="($eq)"/>
            </admst:otherwise>
          </admst:choose>
          <admst:choose>
            <admst:when test="[$epq='']">
              <admst:variable name="epq" select="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="epq" select="($epq)"/>
            </admst:otherwise>
          </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:variable name="epq" select="($xpq/$y-($xp*$yq+$xq*$yp+$x*$ypq)/$y/$y+2*$x*$yp*$yq/$y/$y/$y)"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>

<admst:template match="mapply_ternary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" select="$e"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" select="$e"/>
  <admst:variable name="yp" select="$ep"/>
  <admst:variable name="yq" select="$eq"/>
  <admst:apply-templates select="arg3" match="ddx"/>
  <admst:variable name="z" select="$e"/>
  <admst:variable name="zp" select="$ep"/>
  <admst:variable name="zq" select="$eq"/>
  <admst:variable name="e" select="($x?$y:$z)"/>

  <admst:variable name="ep" select="($x?$yp:$zp)"/>
  <admst:if test="$qprobe">

  <admst:variable name="ep" select="($x?$yp:$zp)"/>

  <admst:variable name="epq" select="fixme"/>
  </admst:if>
</admst:template>

<admst:template match="function">
  <admst:choose>
    <admst:when test="[name='absdelay']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="$e"/>
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:variable name="e" select="_DDT($x)"/>
    </admst:when>
    <admst:when test="[name='\$given']">
      <admst:variable name="arg1" select="%(arguments[1])"/>
      <admst:assert test="$arg1/adms[datatypename='variable']" format="\$given: argument is not a variable\n"/>
      <admst:assert test="$arg1/[input='yes']" format="\$given(%(name)): argument is not a parameter\n"/>
      <admst:choose>
        <admst:when test="$arg1/[parametertype='model']">
          <admst:variable name="e" select="_mpg(%(name),%(name)Given)"/>
        </admst:when>
        <admst:when test="$arg1/[parametertype='instance']">
          <admst:variable name="e" select="_ipg(%(name),%(name)Given)"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="$given(): should not be reached\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="mint_get_circuit_tempK()"/>
    </admst:when>
    <admst:when test="[name='\$mfactor']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="MFACTOR"/>
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="e" select="(BOLTZMANN*mint_get_circuit_tempK()/ELECTRON_CHARGE)"/>   
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" select="$e"/>
          <admst:variable name="xp" select="$ep"/>
          <admst:variable name="xq" select="$eq"/>
          <admst:variable name="xpq" select="$epq"/>
          <admst:variable name="e" select="(BOLTZMANN*$x/ELECTRON_CHARGE)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="_scale"/>
    </admst:when>
    <admst:when test="[name='\$abstime']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" select="_abstime"/>
    </admst:when>
    <admst:when test="[name='ddx']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
      <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="0.0 /*ddx should be top node of expression!*/"/>
    </admst:when>
    <admst:when test="[name='floor']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="floor($e)"/>
    </admst:when>
    <admst:when test="[name='ceil']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="ceil($e)"/>
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e" select="$(fname)($args)"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:variable name="index" select="%(index(subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two argument exactly\n"/>
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" select="$e"/>
      <admst:variable name="xp" select="$ep"/>
      <admst:variable name="xq" select="$eq"/>
      <admst:variable name="xpq" select="$epq"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="y" select="$e"/>
      <admst:variable name="yp" select="$ep"/>
      <admst:variable name="yq" select="$eq"/>
      <admst:variable name="ypq" select="$epq"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="dargs" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$dargs!='']">
          <admst:variable name="dargs" select="$dargs,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="dargs" select="$dargs$ep"/>
      </admst:for-each>
      <admst:variable name="e" select="$(fname)($args)"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" select="0.0"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
    </admst:when>
    <admst:when test="[name='\$given']">
    </admst:when>
    <admst:when test="[name='\$temperature']">
    </admst:when>
    <admst:when test="[name='\$mfactor']">
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="ep" select="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="ep" select="(BOLTZMANN*$xp/ELECTRON_CHARGE)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
    </admst:when>
    <admst:when test="[name='\$abstime']">
    </admst:when>
    <admst:when test="[name='ddx']">
    </admst:when>
    <admst:when test="[name='floor']">
    </admst:when>
    <admst:when test="[name='ceil']">
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:variable name="ep" select="$xp"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
      <admst:variable name="index" select="%(index(subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="$xp*d10_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" select="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="(d11_$(fname)$index*$yp)"/>
        </admst:when>
        <admst:when test="[$yp='0.0']">
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp+d11_$(fname)$index*$yp)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" select="d_$(fname)($args,$dargs)"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:variable name="eq" select="0.0"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
    </admst:when>
    <admst:when test="[name='\$given']">
    </admst:when>
    <admst:when test="[name='\$temperature']">
    </admst:when>
    <admst:when test="[name='\$mfactor']">
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="eq" select="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="eq" select="(BOLTZMANN*$xq/ELECTRON_CHARGE)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
    </admst:when>
    <admst:when test="[name='\$abstime']">
    </admst:when>
    <admst:when test="[name='ddx']">
    </admst:when>
    <admst:when test="[name='floor']">
    </admst:when>
    <admst:when test="[name='ceil']">
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:variable name="eq" select="$xq"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
      <admst:variable name="index" select="%(index(subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="eq" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="eq" select="$xq*d10_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:choose>
        <admst:when test="[$xq='0.0' and $yq='0.0']">
          <admst:variable name="eq" select="0.0"/>
        </admst:when>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="eq" select="(d11_$(fname)$index*$yq)"/>
        </admst:when>
        <admst:when test="[$yq='0.0']">
          <admst:variable name="eq" select="(d10_$(fname)$index*$xq)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="eq" select="(d10_$(fname)$index*$xq+d11_$(fname)$index*$yq)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="eq" select="d_$(fname)($args,$dargs)"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
      <admst:variable name="index" select="%(index(./subexpression/expression/function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:choose>
        <admst:when test="[$x='0.0']">
          <admst:variable name="epq" select="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="epq" select="0.0"/>
        </admst:when>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="epq" select="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="epq" select="(m20_$(fname)($x)*$xq*$xp+d10_$(fname)$index*$xpq)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="epq" select="fixme"/>
      <admst:if test="[$requiredderivateforddx='yes']">
        <admst:warning format="%(name): ddx dependency not implemented\n"/>
      </admst:if>
    </admst:when>
  </admst:choose>
  </admst:if>
</admst:template>


<!-- analog//block -->
<admst:template match="block">
  <admst:text format="{\n"/>
  <admst:apply-templates select="item" match="%(adms/datatypename)"/>
  <admst:text format="}\n"/>
</admst:template>

<!-- analog//blockvariable -->
<admst:template match="blockvariable">
  <admst:text select="variable" format="%(vtype(.)) %(name);\n"/>
  <admst:if test="variable[insource='yes']/probe">

    <admst:for-each select="variable">
      <admst:variable name="myvariable" select="%(.)"/>
      <admst:for-each select="probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:variable name="ddxinsidethisprobe" select="no"/>
          <admst:if test="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidethisprobe" select="yes"/>
          </admst:if>
          <admst:text test="[$ddxinsidethisprobe='yes']" format="#if defined(_DERIVATEFORDDX)\n"/>
          <admst:text test="[$ddxinsidethisprobe='no']" format="#if defined(_DERIVATE)\n"/>
          <admst:text format="double %($myvariable/name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
          <admst:text format="#endif\n"/>
      </admst:for-each>
    </admst:for-each>

    <admst:for-each select="variable">
      <admst:variable name="myvariable" select="%(.)"/>
      <admst:new datatype="list" arguments="list of ddx probes">
        <admst:variable name="ddxprobes" select="%(.)"/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:push into="$ddxprobes/item" select="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
        </admst:for-each>
      </admst:new>
      <admst:text test="$ddxprobes/item" format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="$ddxprobes/item">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="qprobe" select="%(.)"/>
          <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
        </admst:for-each>
      </admst:for-each>
      <admst:text test="$ddxprobes/item" format="#endif\n"/>
    </admst:for-each>
  </admst:if>
</admst:template>

<!-- analog//function: ddx handling -->
<admst:template match="function:precomputation">
  <admst:variable name="index" select="%(index(../function,.))"/>
  <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
  <admst:choose>
    <admst:when test="[name='add']">
      <admst:text format="m00_add(d00_add$index"/>
    </admst:when>
    <admst:when test="[name='div']">
      <admst:text format="m00_div(d00_div$index,d10_$(fname)$index"/>
    </admst:when>
    <admst:when test="[name='mult']">
      <admst:text format="m00_mult(d00_mult$index,d10_mult$index,d11_mult$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="double m00_$(fname)(d00_$(fname)$index"/>
    </admst:otherwise>
  </admst:choose>
  <admst:text select="arguments" format=",%(e(.))"/>
  <admst:text format=")\n"/>
</admst:template>
<admst:template match="function:derivate:precomputation">
  <admst:if test="[hasVoltageDependentFunction='yes']">
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="#if defined(_DERIVATE)\n"/>
          </admst:otherwise>
        </admst:choose>
    <admst:for-each select="function">
      <admst:variable name="index" select="%(index(../function,.))"/>
      <admst:variable name="fname" select="%(funcname(.)/[name='fname']/value)"/>
      <admst:choose>
        <admst:when test="[name='exp']">
            <admst:if test="arguments/math[dependency!='constant']">
              <admst:text format="#define d10_exp$index d00_exp$index\n"/>
            </admst:if>
        </admst:when>
        <admst:when test="[name='add']">
            <admst:if test="arguments/math[dependency!='constant']">
              <admst:text format="#define d10_add$index 1\n"/>
              <admst:text format="#define d11_add$index 1\n"/>
            </admst:if>
        </admst:when>
        <admst:when test="[name='mult']"/>
        <admst:when test="[name='add']"/>
        <admst:when test="[name='div']">
          <admst:for-each select="arguments">
            <admst:variable name="position" select="%(position(.)-1)"/>
            <admst:if test="math[dependency!='constant']">
              <admst:text format="m1$(position)_$(fname)(d1$(position)_$(fname)$index,d00_$(fname)$index,d10_$(fname)$index"/>
              <admst:text select="../arguments" format=",%(e(.))"/>
              <admst:text format=")\n"/>
            </admst:if>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:for-each select="arguments">
            <admst:variable name="position" select="%(position(.)-1)"/>
            <admst:if test="math[dependency!='constant']">
              <admst:text format="double m1%(position(.)-1)_$(fname)(d1%(position(.)-1)_$(fname)$index,d00_$(fname)$index"/>
              <admst:text select="../arguments" format=",%(e(.))"/>
              <admst:text format=")\n"/>
            </admst:if>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
    <admst:text format="#endif\n"/>
  </admst:if>
</admst:template>

<!-- analog//assignment -->
<admst:template match="assignment">
  <admst:variable name="assignment" select="%(.)"/>
  <admst:variable name="rhs" select="%(rhs)"/>
  <admst:variable name="lhs" select="%(lhs)"/>
  <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  <admst:text test="rhs/function" format="{\n"/>
        <admst:for-each select="lhs/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:if test="$lhs/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidederivate" select="yes"/>
          </admst:if>
        </admst:for-each>
  <admst:apply-templates select="rhs/function" match="function:precomputation"/>
  <admst:if test="lhs[insource='yes']">
    <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation"/>
  </admst:if>
  <admst:choose>
    <admst:when test="rhs/tree/adms[datatypename='function']/..[name='ddx']">
      <admst:text format="#if defined(_DDX)\n"/>
      <admst:variable name="ddxprobe" select="%(rhs/tree/arguments[2])"/>
      <admst:text test="lhs[insource='yes']/probe" format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="lhs[insource='yes']/probe">
        <admst:variable name="qprobe" select="%(.)"/>
        <admst:variable name="allepq"/>
        <admst:for-each select="$lhs/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:choose>
            <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
              <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
              <admst:variable name="allepq" select="$allepq+($epq)"/>
            </admst:when>
            <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
              <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
              <admst:variable name="allepq" select="$allepq-($epq)"/>
            </admst:when>
          </admst:choose>
        </admst:for-each>
        <admst:variable name="pprobe" select="%($qprobe)"/>
        <admst:if test="[$requiredderivateforddx='yes']">
          <admst:text format="%(dxname($lhs)/[name='dxname']/value)=$allepq;\n"/>
        </admst:if>
      </admst:for-each>
      <admst:text test="lhs[insource='yes']/probe" format="#endif\n"/>
      <admst:variable name="allep"/>
      <admst:variable name="qprobe"/>
      <admst:for-each select="$lhs/probe">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:choose>
          <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
            <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
            <admst:variable name="allep" select="$allep+($ep)"/>
          </admst:when>
          <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
            <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
            <admst:variable name="allep" select="$allep-($ep)"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:text format="%(lhs/name)=$allep;\n"/>
      <admst:text format="EXIT_IF_ISNAN(%(lhs/name))\n"/>
      <admst:text format="#endif\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:if test="lhs[insource='yes']">
        <admst:variable name="definedrequired" select="yes"/>
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:text format="#if defined(_DERIVATEFORDDX) /* probe=%($lhs/probe) ddxprobe=%($lhs/ddxprobe) */\n"/>
          </admst:when>
          <admst:when test="lhs/probe">
            <admst:text format="#if defined(_DERIVATE) /* probe=%($lhs/probe) ddxprobe=%($lhs/ddxprobe) */\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="definedrequired" select="no"/>
          </admst:otherwise>
        </admst:choose>
        <admst:for-each select="lhs/probe">
          <admst:variable name="pprobe" select="%(.)"/>
          <admst:variable name="ddxinsidethisprobe" select="no"/>
          <admst:if test="$lhs/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidethisprobe" select="yes"/>
          </admst:if>
          <admst:variable name="isinside" select="0"/>
          <admst:if test="$rhs/probe[.=$pprobe]">
            <admst:variable name="isinside" select="1"/>
          </admst:if>
          <admst:variable name="qprobe"/>
          <admst:variable name="ep" select="0.0"/>
          <admst:apply-templates select="[$isinside='1']/$rhs/tree" match="%(adms/datatypename)"/>
          <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']" format="#if defined(_DERIVATE)\n"/>
          <admst:text format="%(dxname($lhs)/[name='dxname']/value)=$ep;\n"/>
          <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']" format="#endif\n"/>
          <admst:text test="[$ddxinsidethisprobe='yes']" format="#if defined(_DERIVATE2)\n"/>
          <admst:for-each select="$lhs[$ddxinsidethisprobe='yes']/probe">
            <admst:variable name="epq" select="0.0"/>
            <admst:variable name="qprobe" select="%(.)"/>
            <admst:apply-templates select="[$isinside='1']/$rhs/tree" match="%(adms/datatypename)"/>
            <admst:text format="  %(ddxname($lhs)/[name='ddxname']/value)=$epq;\n"/>
          </admst:for-each>
          <admst:text test="$lhs[$ddxinsidethisprobe='yes']" format="#endif\n"/>
        </admst:for-each>
        <admst:text test="[$definedrequired='yes']" format="#endif\n"/>
        <admst:variable name="ddxinsidederivate" select="no"/>
      </admst:if>
      <admst:variable name="qprobe"/>
      <admst:apply-templates select="lhs" match="variable"/>
      <admst:text format="$e=%(e(rhs/tree));\n"/>
      <admst:text format="EXIT_IF_ISNAN($e)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:text test="rhs/function" format="}\n"/>
  <admst:text test="[dynamic='yes']" format="#endif\n"/>
</admst:template>

<!-- analog//contribution -->
<admst:template match="contribution">
  <admst:choose>
    <admst:when test="[whitenoise='yes' or flickernoise='yes']">
      <admst:variable name="SkipFVariable" select="y"/>
        <admst:variable name="dependency" select="%(math/dependency)"/>
        <admst:if test="[whitenoise='yes']">
          <admst:if test="[$dependency='constant']">
            <admst:text format="pInst-&gt;tnoise%(index($tnoise/item,.))="/>
          </admst:if>
          <admst:if test="[$dependency!='constant']">
            <admst:text format="pInst-&gt;wnoise%(index($wnoise/item,.))="/>
          </admst:if>
          <admst:apply-templates select="rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
          <admst:text format="$e;\n"/>
        </admst:if>
        <admst:if test="[flickernoise='yes']">
          <admst:text format="pInst-&gt;fpnoise%(index($fnoise/item,.))="/>
          <admst:apply-templates select="rhs/tree/arguments[1]" match="%(adms/datatypename)"/>
          <admst:text format="$e;\n"/>
          <admst:text format="pInst-&gt;fenoise%(index($fnoise/item,.))="/>
          <admst:apply-templates select="rhs/tree/arguments[2]" match="%(adms/datatypename)"/>
          <admst:text format="$e;\n"/>
        </admst:if>
      <admst:variable name="SkipFVariable" select="n"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="contribution:nonoise"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<admst:template match="contribution:nonoise:mint">
  <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  <admst:text test="rhs/function" format="{\n"/>
  <admst:apply-templates select="rhs/function" match="function:precomputation"/>
  <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation"/>
  <admst:variable name="sourcepnode" select="%(lhs/branch/pnode)"/>
  <admst:variable name="sourcennode" select="%(lhs/branch/nnode)"/>
  <admst:variable name="sourcepnodename" select="%($sourcepnode/name)"/>
  <admst:variable name="sourcennodename" select="%($sourcennode/name)"/>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:variable name="jname" select="dQ_dV"/>
      <admst:choose>
        <admst:when test="$sourcennode[grounded='no']">
          <admst:text format="charges_$(sourcepnodename)_$(sourcennodename) += %(e(rhs/tree));\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="charges_$(sourcepnodename)_$(sourcepnodename) += %(e(rhs/tree));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="jname" select="dI_dV"/>
      <admst:choose>
        <admst:when test="$sourcennode[grounded='no']">
          <admst:text format="currents[$sourcepnodename*TotalNodes+$sourcennodename] += %(e(rhs/tree));\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="currents[$sourcepnodename*TotalNodes+$sourcepnodename] += %(e(rhs/tree));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:text format="#if defined(_DERIVATE)\n"/>
  <admst:for-each select="rhs/probe">
    <admst:variable name="probepnode" select="%(branch/pnode)"/>
    <admst:variable name="probennode" select="%(branch/nnode)"/>
    <admst:variable name="probepnodename" select="%($probepnode/name)"/>
    <admst:variable name="probennodename" select="%($probennode/name)"/>
    <admst:variable name="pprobe" select="%(.)"/>
    <admst:apply-templates select="../tree" match="%(adms/datatypename)"/>
    <admst:choose>
      <admst:when test="$probennode[grounded='no']">
        <admst:if test="$sourcennode[grounded='no']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probennodename]-=$ep;\n"/>
          <admst:text format="  $jname[$sourcennodename*TotalNodes+$probepnodename]-=$ep;\n"/>
          <admst:text format="  $jname[$sourcennodename*TotalNodes+$probennodename]+=$ep;\n"/>
        </admst:if>
        <admst:if test="$sourcennode[grounded='yes']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probennodename]-=$ep;\n"/>
        </admst:if>
      </admst:when>
      <admst:otherwise>
        <admst:if test="$sourcennode[grounded='no']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
          <admst:text format="  $jname[$sourcennodename*TotalNodes+$probepnodename]-=$ep;\n"/>
        </admst:if>
        <admst:if test="$sourcennode[grounded='yes']">
          <admst:text format="  $jname[$sourcepnodename*TotalNodes+$probepnodename]+=$ep;\n"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
  <admst:text format="#endif\n"/>
  <admst:text test="rhs/function" format="}\n"/>
  <admst:text select="[dynamic='yes']" format="#endif\n"/>
</admst:template>

<admst:template match="contribution:nonoise">
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:choose>
      <admst:when test="[dynamic='yes']">
        <admst:text format="#if defined(_DYNAMIC)\n"/>
      </admst:when>
    </admst:choose>
    <admst:text format="{\n"/>
    <admst:for-each select="rhs/function">
      <admst:value-of select="position(.)-1"/>
      <admst:apply-templates select="." match="function:getname"/>
      <admst:text format="double __%s_%s=0.0;\n"/>
    </admst:for-each>
    <admst:apply-templates select="." match="ddx:function:computation"/>
  </admst:if>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:text format="  _load_dynamic_"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="  _load_static_"/>
    </admst:otherwise>
  </admst:choose>
  <admst:choose>
    <admst:when test="lhs/branch/nnode[grounded='no']">
      <admst:value-of select="lhs/branch/nnode/name"/>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="residual2(%s,%s,%(e(rhs/tree)))\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="lhs/branch/pnode/name"/>
      <admst:text format="residual1(%s,%(e(rhs/tree)))\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:for-each select="rhs/probe">
    <admst:variable name="probepnode" select="%(branch/pnode)"/>
    <admst:variable name="probennode" select="%(branch/nnode)"/>
    <admst:variable name="probepnodename" select="%($probepnode/name)"/>
    <admst:variable name="probennodename" select="%($probennode/name)"/>
    <admst:variable name="pprobe" select="%(.)"/>
    <admst:apply-templates select="../tree" match="%(adms/datatypename)"/>
    <admst:choose>
      <admst:when test="..[dynamic='yes']">
        <admst:text format="  _load_dynamic_"/>
      </admst:when>
      <admst:otherwise>
        <admst:text format="  _load_static_"/>
      </admst:otherwise>
    </admst:choose>
    <admst:if test="branch/pnode[grounded='no']">
      <admst:if test="../../lhs/branch/pnode[grounded='no']">
        <admst:choose>
          <admst:when test="branch/nnode[grounded='no']">
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian4(%s,%s,%s,%s,$ep)\n"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <admst:value-of select="branch/nnode/name"/>
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian2p(%s,%s,%s,$ep)\n"/>
            </admst:if>
          </admst:when>
          <admst:otherwise>
            <admst:if test="../../lhs/branch/nnode[grounded='no']">
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/nnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian2s(%s,%s,%s,$ep)\n"/>
            </admst:if>
            <admst:if test="../../lhs/branch/nnode[grounded='yes']">
              <admst:value-of select="branch/pnode/name"/>
              <admst:value-of select="../../lhs/branch/pnode/name"/>
              <admst:text format="jacobian1(%s,%s,$ep)\n"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:if>
  </admst:for-each>
  <admst:if test="rhs[not(nilled(function[class='builtin']))]">
    <admst:text format="}\n"/>
    <admst:if test="[dynamic='yes']">
      <admst:text format="#endif /* _DYNAMIC */\n"/>
    </admst:if>
  </admst:if>
</admst:template>

<!-- analog//conditional -->
<admst:template match="conditional">
  <admst:text select="if[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:text test="if/function" format="{\n"/>
  <admst:apply-templates select="if/function" match="function:precomputation"/>
  <admst:text format="if\n(%(e(if/tree)))\n"/>
  <admst:text select="then/adms[datatypename!='block']" format="{\n"/>
  <admst:apply-templates select="then" match="%(adms/datatypename)"/>
  <admst:text select="then/adms[datatypename!='block']" format="}\n"/>
  <admst:if test="else">
    <admst:text format="else\n"/>
    <admst:text test="else/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="else" match="%(adms/datatypename)"/>
    <admst:text test="else/adms[datatypename!='block']" format="}\n"/>
  </admst:if>
  <admst:text test="if/function" format="}\n"/>
  <admst:text select="if[dynamic='yes']" format="#endif /* if(...) */\n"/>
</admst:template>

<!-- analog//nilled -->
<admst:template match="nilled">
</admst:template>

<!-- analog//whileloop -->
<admst:template match="whileloop">
  <admst:text select="while[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:variable name="SkipFVariable" select="y"/>
  <admst:text format="while\n(%(e(while/tree)))\n"/>
  <admst:variable name="SkipFVariable" select="n"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="{\n"/>
  <admst:apply-templates select="whileblock" match="%(adms/datatypename)"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="}\n"/>
  <admst:text select="while[dynamic='yes']" format="#endif /*&lt;/dynamic_while&gt;*/\n"/>
</admst:template>

<!-- analog//callfunctions -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">printf(</admst:when>
    <admst:when test="function[name='\$warning']">_warning(</admst:when>
    <admst:when test="function[name='\$error']">_error(</admst:when>
    <admst:when test="function[name='\$finish']">_finish(</admst:when>
    <admst:when test="function[name='\$stop']">_stop(</admst:when>
    <admst:otherwise>
      <admst:fatal format="function not supported: %(function/name)\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:join select="function/arguments" separator=",">
    %(e(tree))
    <admst:if test="[position(.)=1]">&quot;\\n&quot;</admst:if>
  </admst:join>
  <admst:text format="); fflush(stdout);\n"/>
</admst:template>

<!-- analog/code -->
<!-- save all variables used for local declaration -->
<admst:variable name="ddxinsidederivate" select="no"/>
<admst:template match="variable:declaration">
  <admst:variable name="myvariable" select="%(.)"/>
  <admst:new datatype="list" arguments="list of ddx probes">
    <admst:variable name="ddxprobes" select="%(.)"/>
    <admst:for-each select="$myvariable/probe">
      <admst:variable name="pprobe" select="%(.)"/>
      <admst:push into="$ddxprobes/item" select="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
    </admst:for-each>
  </admst:new>
  <admst:if test="block/adms[datatypename='module']">
    <admst:text test="[static='no' and dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
    <admst:text test="[scope='local']" format="%(vtype(.)) %(name);\n"/>
    <admst:if test="[insource='yes']/probe">
      <admst:for-each select="probe">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:if test="../ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
          <admst:variable name="ddxinsidederivate" select="yes"/>
        </admst:if>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[$ddxinsidederivate='yes']">
          <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="#if defined(_DERIVATE)\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:text select="probe" format="double %(../name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
      <admst:text test="[$ddxinsidederivate='yes']" format="#if defined(_DERIVATE2)\n"/>
      <admst:for-each select="$ddxprobes/item">
        <admst:variable name="pprobe" select="%(.)"/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="qprobe" select="%(.)"/>
          <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
        </admst:for-each>
      </admst:for-each>
      <admst:text test="[$ddxinsidederivate='yes']" format="#endif\n"/>
      <admst:variable name="ddxinsidederivate" select="no"/>
      <admst:text format="#endif\n"/>
    </admst:if>
    <admst:text test="[static='no' and dynamic='yes']" format="#endif\n"/>
  </admst:if>
</admst:template>
<admst:template match="block:local:declaration">
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="module/evaluation/variable" select="lhs" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:apply-templates select="item" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="block:local:declaration"/>
      <admst:apply-templates select="else" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="'datatypename=%(adms/datatypename)': should not be reached %s\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>
<admst:template match="analog:evaluate">
  <admst:text select="$fnoise/item" format="pInst-&gt;fpnoise%(index($fnoise/item,.))=0.0; pInst-&gt;fenoise%(index($fnoise/item,.))=0.0;\n"/>
  <admst:text select="$tnoise/item" format="pInst-&gt;tnoise%(index($tnoise/item,.))=0.0;\n"/>
  <admst:text select="$wnoise/item" format="pInst-&gt;wnoise%(index($wnoise/item,.))=0.0;\n"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name!='initial_model' and name!='initial_instance']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
    <admst:if test="adms[datatypename!='block']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:choose>
      <admst:when test="adms[datatypename!='block']">
        <admst:apply-templates select="." match="%(adms/datatypename)"/>
      </admst:when>
      <admst:otherwise>
        <admst:if test="[name!='initial_model' and name!='initial_instance']">
          <admst:apply-templates select="." match="block"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
</admst:template>
<admst:template match="analog:initializeModel">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_model']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_model']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>
<admst:template match="analog:initializeInstance">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<admst:value-to select="/simulator/package_name" value="ads2002"/>
<admst:value-to select="/simulator/package_tarname" value="ads2002"/>
<admst:value-to select="/simulator/package_version" value="2.2.0.0"/>
<admst:value-to select="/simulator/package_string" value="ads2002 2.2.0.0"/>
<admst:value-to select="/simulator/package_bugreport" value="r29173@users.sourceforge.net"/>

<!--
* This template returns the description of an instance or 
* a model parameter. It works for both formats of :
*   `ATTR(info="description"  ...)
* or
*   `ATTR(desc="description"  ...)
* This template is used in the creation of the mint:defineParameters 
* routine. If there is no description given in the VerilogA file, 
* it returns a NULL. The returned value is used in the 'description'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->
<admst:template match="variable:desc">
  <admst:choose>
    <admst:when test="attribute[name='desc' or name='info']">
      <admst:return name="variable:desc" value="&quot;%(attribute[name='desc' or name='info']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:desc" value="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* This template returns the unit of an instance or 
* a model parameter as given in the VA file.
* This template is used in the creation of the mint:defineParameters 
* routine. If there is no 'unit' string given in the VerilogA file, 
* it returns a NULL. The returned value is used in the 'unit'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->
<admst:template match="variable:unit">
  <admst:choose>
    <admst:when test="attribute[name='unit']">
      <admst:return name="variable:unit" value="&quot;%(attribute[name='unit']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:unit" value="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* This template returns the default value of an instance or 
* a model parameter as given in the VA file.
* This template is used in the creation of the mint:defineParameters 
* routine. The returned value is used in the 'default'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->

<admst:template match="variable:paramdef">
  <admst:return name="name" value="%(name)"/>
  <admst:apply-templates select="." match="variable:desc">
    <admst:return name="desc" value="%(returned('variable:desc')/value)"/>
  </admst:apply-templates>
  <admst:apply-templates select="." match="variable:unit">
    <admst:return name="unit" value="%(returned('variable:unit')/value)"/>
  </admst:apply-templates>
  <admst:return name="minttype" value="%(type)"/>
</admst:template>

<!-- Do not create temp variables for functions inside while(), for()-->
<admst:variable name="requiredderivateforddx" select="no"/>
<admst:variable name="SkipFVariable" select="n"/>
<admst:for-each select="/module">
  <admst:variable name="module" select="%(name)"/>
  <admst:choose>
    <admst:when test="attribute[name='desc']">
      <admst:variable name="module:desc" select="%(attribute[name='desc']/value)"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="module:desc" select="no description"/>
    </admst:otherwise>
  </admst:choose>
  <admst:variable name="file" select="%(attribute[name='ngspicename']/value).hxx"/>
  <admst:open file="$file">
    <admst:text format="\n"/>
    <admst:apply-templates select="." match="c:math_h"/>
    <admst:apply-templates select="." match="wrapper"/>
    <admst:text format="\n"/>
    <admst:apply-templates select="analog/code" match="analog:evaluate"/>
    <admst:message format="$file: created\n"/>
  </admst:open>
</admst:for-each>
</admst>

<?escript name="../admst/ngspiceMODULE.c.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
  $Id: ngspiceMODULE.c.xml,v 1.4 2006/03/05 09:38:41 pnenzi Exp $
  $Log: ngspiceMODULE.c.xml,v $
  Revision 1.4  2006/03/05 09:38:41  pnenzi

  Updated version to 2.2.0

  Revision 1.3  2006/02/21 08:05:18  dwarning
  Introduction of alias names for modules to prevent cryptic naming.

  Revision 1.2  2006/02/02 17:56:31  pnenzi

  Changed adms required version to 2.1.3 ,J

  Revision 1.1  2006/01/31 17:53:48  pnenzi

  Initial import for admst (Verilog-AMS) translators for ngspice.

-->

<!--
     Written by Laurent Lemaitre - r29173@users.sourceforge.net
     Documentation:
       http://sourceforge.net/docman/display_doc.php?docid=18993&group_id=84289
     Target Interface: ngspice
     Supported by adms-1.x.x
     This file is used by adms - http://sourceforge.net/projects/mot-adms.
     adms is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
     adms is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with adms; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">


<admst:template match="code">
<admst:value-of select="attribute[name='ngspicename']/value"/>
<admst:variable name="module" select="%s"/>

#include &quot;ngspice.h&quot;
#include &quot;devdefs.h&quot;
#include &quot;$(module)defs.h&quot;
#include &quot;suffix.h&quot;

<admst:text format="IFparm $(module)pTable[] = {\n"/>
<admst:join select="variable[parametertype='instance' and input='yes']" separator=",\n">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:text format=" IOP(&quot;%s&quot;,$(module)_instance_%s,IF_REAL,&quot;%s&quot;)"/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:text format=" IOP(&quot;%s&quot;,$(module)_instance_%s,IF_INTEGER,&quot;%s&quot;)"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="parameter of type 'string' not supported\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:join>
<admst:text format="\n};\n"/>
<admst:text format="IFparm $(module)mPTable[] = {\n"/>
<admst:join select="variable[parametertype='model' and input='yes']" separator=",\n">
  <admst:choose>
    <admst:when test="[type='real']">
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:text format=" IOP(&quot;%s&quot;,$(module)_model_%s,IF_REAL,&quot;%s&quot;)"/>
    </admst:when>
    <admst:when test="[type='integer']">
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:value-of select="name"/>
      <admst:text format=" IOP(&quot;%s&quot;,$(module)_model_%s,IF_INTEGER,&quot;%s&quot;)"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="parameter of type 'string' not supported\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:join>
<admst:text format="\n};\n"/>

char *$(module)names[] = {
<admst:join select="node[grounded='no']" separator=",\n">
  <admst:choose>
    <admst:when test="attribute[name='name']">
      <admst:for-each select="attribute[name='name']">
        <admst:value-of select="value"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:value-of select="name"/>
    </admst:otherwise>
  </admst:choose>
  <admst:text format=" &quot;%s&quot;"/>
</admst:join>
};

int $(module)nSize = NUMELEMS($(module)names);
int $(module)pTSize = NUMELEMS($(module)pTable);
int $(module)mPTSize = NUMELEMS($(module)mPTable);
int $(module)iSize = sizeof($(module)instance);
int $(module)mSize = sizeof($(module)model);

</admst:template>

<admst:for-each select="/module">
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:open file="%s.c">
    <admst:value-of select="/simulator/package_string"/>
    <admst:text format="/***\n*** Interface: %s\n"/>
    <admst:value-of select="/simulator/currentdate"/>
    <admst:value-of select="/simulator/fullname"/>
    <admst:text format=" *** created by: %s - %s ***/\n"/>
    <admst:apply-templates select="." match="code"/>
  </admst:open>
  <admst:value-of select="attribute[name='ngspicename']/value"/>
  <admst:message format="%s.c: file created\n"/>
</admst:for-each>

</admst>
