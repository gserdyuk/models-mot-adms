# 1 "admsva/mextram.va"
# 1 "frontdef.inc"


# 1 "discipline.h"






# 9 "discipline.h"




discipline logic
  domain discrete;
enddiscipline






nature Current
  units = "A";
  access = I;
  idt_nature = Charge;
# 29 "discipline.h"
  abstol = 1e-12;

endnature

nature Charge
  units = "coul";
  access = Q;
  ddt_nature = Current;
# 40 "discipline.h"
  abstol = 1e-14;

endnature

nature Voltage
  units = "V";
  access = V;
  idt_nature = Flux;
# 51 "discipline.h"
  abstol = 1e-6;

endnature

nature Flux
  units = "Wb";
  access = Phi;
  ddt_nature = Voltage;
# 62 "discipline.h"
  abstol = 1e-9;

endnature

discipline electrical
  potential Voltage;
  flow Current;
enddiscipline

discipline voltage
  potential Voltage;
enddiscipline
discipline current
  potential Current;
enddiscipline


nature Magneto_Motive_Force
  units = "A*turn";
  access = MMF;
# 85 "discipline.h"
  abstol = 1e-12;

endnature

discipline magnetic
  potential Magneto_Motive_Force;
  flow Flux;
enddiscipline


nature Temperature
  units = "K";
  access = Temp;
# 101 "discipline.h"
  abstol = 1e-4;

endnature

nature Power
  units = "W";
  access = Pwr;
# 111 "discipline.h"
  abstol = 1e-9;

endnature

discipline thermal
  potential Temperature;
  flow Power;
enddiscipline


nature Position
  units = "m";
  access = Pos;
  ddt_nature = Velocity;
# 128 "discipline.h"
  abstol = 1e-6;

endnature

nature Velocity
  units = "m/s";
  access = Vel;
  ddt_nature = Acceleration;
  idt_nature = Position;
# 140 "discipline.h"
  abstol = 1e-6;

endnature

nature Acceleration
  units = "m/s^2";
  access = Acc;
  ddt_nature = Impulse;
  idt_nature = Velocity;
# 152 "discipline.h"
  abstol = 1e-6;

endnature

nature Impulse
  units = "m/s^3";
  access = Imp;
  idt_nature = Acceleration;
# 163 "discipline.h"
  abstol = 1e-6;

endnature

nature Force
  units = "N";
  access = F;
# 173 "discipline.h"
  abstol = 1e-6;

endnature

discipline kinematic
  potential Position;
  flow Force;
enddiscipline
discipline kinematic_v
  potential Velocity;
  flow Force;
enddiscipline


nature Angle
  units = "rads";
  access = Theta;
  ddt_nature = Angular_Velocity;
# 194 "discipline.h"
  abstol = 1e-6;

endnature

nature Angular_Velocity
  units = "rads/s";
  access = Omega;
  ddt_nature = Angular_Acceleration;
  idt_nature = Angle;
# 206 "discipline.h"
  abstol = 1e-6;

endnature

nature Angular_Acceleration
  units = "rads/s^2";
  access = Alpha;
  idt_nature = Angular_Velocity;
# 217 "discipline.h"
  abstol = 1e-6;

endnature

nature Angular_Force
  units = "N*m";
  access = Tau;
# 227 "discipline.h"
  abstol = 1e-6;

endnature

discipline rotational
  potential Angle;
  flow Angular_Force;
enddiscipline
discipline rotational_omega
  potential Angular_Velocity;
  flow Angular_Force;
enddiscipline

# 4 "frontdef.inc" 
 















# 25 "frontdef.inc"




 






# 42 "frontdef.inc"










  







  







 















# 2 "admsva/mextram.va" 


 
module bjt504_va (c, b, e, s, dt); 



# 12 "admsva/mextram.va"

  
     inout c, b, e, s, dt; 
  
     electrical 	c      (*info="external collector node"*);
     electrical 	b      (*info="external base node"*);
     electrical 	e      (*info="external emitter node"*);
     electrical 	s      (*info="external substrate node"*);
     electrical 	dt     (*info="external thermal node"*);
  
  
     electrical 	c1     (*info="internal collector node 1"*);
     electrical 	e1     (*info="internal emitter node"*);
     electrical 	b1     (*info="internal base node 1"*);
     electrical 	b2     (*info="internal base node 2"*);
     electrical 	c2     (*info="internal collector node 2"*);
     electrical 	c3     (*info="internal collector node 3"*);
     electrical 	c4     (*info="internal collector node 4"*);
  
     electrical 	noi    (*info="internal noise node"*);

# 1 "parameters.inc"

  
parameter integer LEVEL = 504      from [504:505)      
                  (*info="Model level"*);  
parameter real    TREF  = 25.0     from [-273.0:inf)   
                  (*info="Reference temperature"*);   
parameter real    DTA   = 0.0                          
                  (*info="Difference between the local and global ambient temperatures"*);
parameter integer EXMOD = 1        from [0:1]          
                  (*info="Flag for extended modeling of the reverse current gain"*);   
parameter integer EXPHI = 1        from [0:1]          
                  (*info="Flag for the distributed high-frequency effects in transient"*);   
parameter integer EXAVL = 0        from [0:1]          
                  (*info="Flag for extended modeling of avalanche currents"*);   
   
parameter real    IS    = 22.0a    from (0.0:inf)      
                  (*info="Collector-emitter saturation current"*);    
parameter real    IK    = 0.1      from [1.0p:inf)     
                  (*info="Collector-emitter high injection knee current"*);   
parameter real    VER   = 2.5      from [0.01:inf)     
                  (*info="Reverse Early voltage"*);   
parameter real    VEF   = 44.0     from [0.01:inf)     
                  (*info="Forward Early voltage"*);   
parameter real    BF    = 215.0    from [0.1m:inf)     
                  (*info="Ideal forward current gain"*);   
parameter real    IBF   = 2.7f     from [0.0:inf)      
                  (*info="Saturation current of the non-ideal forward base current"*);   
parameter real    MLF   = 2.0      from [0.1:inf)      
                  (*info="Non-ideality factor of the non-ideal forward base current"*);   
parameter real    XIBI  = 0.0      from [0.0:1.0]      
                  (*info="Part of ideal base current that belongs to the sidewall"*);   
parameter real    BRI   = 7.0      from [1.0e-4:inf)   
                  (*info="Ideal reverse current gain"*);   
parameter real    IBR   = 1.0f     from [0.0:inf)      
                  (*info="Saturation current of the non-ideal reverse base current"*);   
parameter real    VLR   = 0.2                          
                  (*info="Cross-over voltage of the non-ideal reverse base current"*);   
parameter real    XEXT  = 0.63     from [0.0:1.0]      
                  (*info="Part of currents and charges that belong to extrinsic region"*);     
   
parameter real    WAVL  = 1.1u     from [1.0n:inf)     
                  (*info="Epilayer thickness used in weak-avalanche model"*);   
parameter real    VAVL  = 3.0      from [0.01:inf)     
                  (*info="Voltage determining curvature of avalanche current"*);   
parameter real    SFH   = 0.3      from [0.0:inf)      
                  (*info="Current spreading factor of avalanche model when EXAVL=1"*);   



parameter real    RE    = 5.0      from [1.0m:inf)     
                  (*info="Emitter resistance"*);   
parameter real    RBC   = 23.0     from [1.0m:inf)     
                  (*info="Constant part of the base resistance"*);   
parameter real    RBV   = 18.0     from [1.0m:inf)     
                  (*info="Zero-bias value of the variable part of the base resistance"*);   
parameter real    RCC   = 12.0     from [1.0m:inf)     
                  (*info="Constant part of the collector resistance"*);   
parameter real    RCV   = 150.0    from [1.0m:inf)     
                  (*info="Resistance of the un-modulated epilayer"*);   
parameter real    SCRCV = 1250.0   from [1.0m:inf)     
                  (*info="Space charge resistance of the epilayer"*);   
parameter real    IHC   = 4.0m     from [1.0p:inf)     
                  (*info="Critical current for velocity saturation in the epilayer"*);   
parameter real    AXI   = 0.3      from [0.02:inf)     
                  (*info="Smoothness parameter for the onset of quasi-saturation"*);   
  
parameter real    CJE    = 73.0f   from [0.0:inf)      
                  (*info="Zero-bias emitter-base depletion capacitance"*);   
parameter real    VDE    = 0.95    from [0.05:inf)     
                  (*info="Emitter-base diffusion voltage"*);   
parameter real    PE     = 0.4     from [0.01:0.99)    
                  (*info="Emitter-base grading coefficient"*);   
parameter real    XCJE   = 0.4     from [0.0:1.0]      
                  (*info="Sidewall fraction of the emitter-base depletion capacitance"*);   
parameter real    CBEO   = 0.0     from [0.0:inf)      
                  (*info="Emitter-base overlap capacitance"*);     
  
parameter real    CJC    = 78.0f   from [0.0:inf)      
                  (*info="Zero-bias collector-base depletion capacitance"*);   
parameter real    VDC    = 0.68    from [0.05:inf)     
                  (*info="Collector-base diffusion voltage"*);   
parameter real    PC     = 0.5     from [0.01:0.99)    
                  (*info="Collector-base grading coefficient"*);   
parameter real    XP     = 0.35    from [0.0:0.99)     
                  (*info="Constant part of Cjc"*);   
parameter real    MC     = 0.5     from [0.0:1.0)      
                  (*info="Coefficient for current modulation of CB depletion capacitance"*);     
parameter real    XCJC   = 32.0m   from [0.0:1.0]      
                  (*info="Fraction of CB depletion capacitance under the emitter"*);   


parameter real    RCBLX   = 1.0    from [1.0m:inf)      
                  (*info="Resistance Collector Buried Layer eXtrinsic"*);   
parameter real    RCBLI   = 1.0    from [1.0m:inf)      
                  (*info="Resistance Collector Buried Layer Intrinsic"*);   
parameter real    CBCO   = 0.0     from [0.0:inf)      
                  (*info="Collector-base overlap capacitance"*);    
  
parameter real    MTAU    = 1.0    from [0.1:inf)      
                  (*info="Non-ideality factor of the emitter stored charge"*);   
parameter real    TAUE    = 2.0p   from [0.0:inf)      
                  (*info="Minimum transit time of stored emitter charge"*);   
parameter real    TAUB    = 4.2p   from (0.0:inf)      
                  (*info="Transit time of stored base sharge"*);   
parameter real    TEPI    = 41.0p  from [0.0:inf)      
                  (*info="Transit time of stored epilayer charge"*);   
parameter real    TAUR    = 520.0p from [0.0:inf)      
                  (*info="Transit time of reverse extrinsic stored base charge"*);    
   
parameter real    DEG     = 0.0                        
                  (*info="Bandgap difference over the base"*);   
parameter real    XREC    = 0.0    from [0.0:inf)      
                   (*info="Pre-factor of the recombination part of Ib1"*);     
   
parameter real    AQBO    = 0.3                        
                  (*info="Temperature coefficient of the zero-bias base charge"*);   
parameter real    AE      = 0.0                        
                  (*info="Temperature coefficient of the resistivity of the emitter"*);   
parameter real    AB      = 1.0                        
                  (*info="Temperature coefficient of the resistivity of the base"*);   
parameter real    AEPI    = 2.5                        
                  (*info="Temperature coefficient of the resistivity of the epilayer"*);   
parameter real    AEX     = 0.62                       
                  (*info="Temperature coefficient of the resistivity of the extrinsic base"*);     
parameter real    AC      = 2.0                        
                  (*info="Temperature coefficient of the resistivity of the collector contact"*);   

parameter real    ACBL    = 2.0    from [0.0:inf)                            
                  (*info="Temperature coefficient of the resistivity of the collector buried layer"*);   
parameter real    DVGBF   = 50.0m                      
                  (*info="Band-gap voltage difference of the forward current gain"*);    
parameter real    DVGBR   = 45.0m                      
                  (*info="Band-gap voltage difference of the reverse current gain"*);   
parameter real    VGB     = 1.17   from [0.1:inf)      
                  (*info="Band-gap voltage of the base"*);   
parameter real    VGC     = 1.18   from [0.1:inf)      
                  (*info="Band-gap voltage of the collector"*);   
parameter real    VGJ     = 1.15   from [0.1:inf)      
                  (*info="Band-gap voltage recombination emitter-base junction"*);   
parameter real    DVGTE   = 0.05                       
                  (*info="Band-gap voltage difference of emitter stored charge"*);   
parameter real    DAIS    = 0.0                       
                  (*info="Fine tuning of temperature dependence of C-E saturation current"*);  
   
parameter real    AF      = 2.0    from [0.01:inf)     
                  (*info="Exponent of the Flicker-noise"*);   
parameter real    KF      = 20.0p  from [0.0:inf)      
                  (*info="Flicker-noise coefficient of the ideal base current"*);   
parameter real    KFN     = 20.0p  from [0.0:inf)      
                  (*info="Flicker-noise coefficient of the non-ideal base current"*);   
parameter integer KAVL    = 0      from [0:1]          
                  (*info="Switch for white noise contribution due to avalanche"*); 


parameter real    ISS     = 48.0a  from [0.0:inf)      
                  (*info="Base-substrate saturation current"*);   
parameter real    IKS     = 250.0u from [1.0p:inf)     
                  (*info="Base-substrate high injection knee current"*);   
parameter real    CJS     = 315.0f from [0:inf)      
                  (*info="Zero-bias collector-substrate depletion capacitance"*);   
parameter real    VDS     = 0.62   from (0.05:inf)     
                  (*info="Collector-substrate diffusion voltage"*);   
parameter real    PS      = 0.34   from (0.01:0.99)    
                  (*info="Collector-substrate grading coefficient"*);   
parameter real    VGS     = 1.20   from [0.1:inf)      
                  (*info="band-gap voltage of the substrate"*);   
parameter real    AS      = 1.58                       
                  (*info="Substrate temperature coefficient"*);   

 

parameter real    RTH     = 300.0  from (0.0:inf)      
                  (*info="Thermal resistance"*);   
parameter real    CTH     = 3.0n   from [0.0:inf)      
                  (*info="Thermal capacitance"*); 
parameter real    ATH     = 0.0                        
                  (*info="Temperature coefficient of the thermal resistance"*);      


parameter real    MULT    = 1.0      from (0.0:inf)      
                  (*info="Multiplication factor"*);  
 


  

parameter integer TYPE    = 1      from [-1:1]  
                  (*info="Flag for NPN (1) or PNP (-1) transistor type"*);   
# 192 "parameters.inc"



# 34 "admsva/mextram.va"
# 1 "variables.inc"


real _circuit_gmin;


      
real An, Bn;   
  

     
real Tk, Trk, tN, Tki, Tamb;    
real Vt, Vtr, VtINV, VtrINV, VdtINV;   
real Vdt;
   
real UdeT, VDE_T, UdcT, VDC_T;   
real CJE_T, CJC_T, XP_T;    
real CJCscale, CJCscaleINV;   
   
real RE_T, RBV_T, RBC_T, RCV_T;     

real RCCxx_T, RCCex_T, RCCin_T;

real BF_T, BRI_T;     
   
real IS_T, IK_T, IBF_T, IBR_T, VEF_T, VER_T;    
   
real TAUE_T, TAUB_T, TEPI_T, TAUR_T;    
real BnT, DEG_T, Tk300;   
  

real RTH_Tamb; 



real UdsT, VDS_T, CJS_T, ISS_T, IKS_T; 



   
real invMULT;   
real IS_TM, IK_TM, IBF_TM, IBR_TM, IHC_M;   
real CJE_TM, CJC_TM;     
   
real RE_TM, RBC_TM, RBV_TM, RCV_TM, SCRCV_M;   

real RCCxx_TM, RCCex_TM, RCCin_TM;

real GCCxx_TM, GCCex_TM, GCCin_TM;


real KF_M, KFN_M;   


real RTH_Tamb_M, CTH_M;

  

real ISS_TM, IKS_TM, CJS_TM;




   
real K0, Kw, pW, Ec, Ic1c2;    
real Vqs_th, Vqs, Iqs;    
real alpha, vyi, yi, xi_w, xi_w1;   
real gp0, gp02, p0star, Vb2c2star, eVb2c2star;    
real B1, B2, Vxi0, Vch, Icap, pav;     
  

   
real Vfe, Vje, Vte;     
real Vjunc, bjc, Vfc, Vjc, fI, Vcv, Vtc;   
  

   
real If0, f1, f2, n0, nB;   
real q0I, q1I, qBI, Ir, If, In;   
  

   
real Xext1;
real Ib1, Ib1_s, Ib2, Ib3;                 
real Ibf0, Iex, Isub;                         
real g1, g2, pWex, nBex;   
real Xg1, XnBex, XIMex, XIMsub, Vex, VBex, Fex, XIex;   


real XIsub, Isf;

  

   
real q0Q, q1Q, qBQ, Rb2, Ib1b2;   
real dVteVb2e1, dVteVje, dVjeVb2e1;   
real dQteVb2e1, dQbeVb2e1, dQeVb2e1;  
real dn0Vb2e1;  
  

   
real dEdx0, xd, Weff, Wd, Eav, E0, Em, SHw, Efi, Ew;    
real lambda, Gem, Gmax, Iavl;   
real Icap_IHC;  
  

real power;   

 

   
real Qte, Vje_s, Qte_s;     
real Qtc;    
real Qb0, Qbe, Qbc, Qb1b2;    
real Qbe_qs, Qbc_qs;
real Vjcex, Vtexv, Qtex, XVjcex, XVtexv, XQtex;      


real Vfs, Vjs, Qts;      


real Qe0, Qe;    
real Qepi0, Qepi, Xg2, XpWex, XQex;   
real Qex;  
real CBEO_M, CBCO_M;  
  

  
real Vb2c1, Vb2c2, Vb2e1, Vb1e1, Vb1b2, Vb1c4, Vc1c2;

real Vc3c4, Vc4c1;


real Vsc1, Vsc3, Vsc4; 

real Vee1, Vbb1, Vbc3, Vcc3, Vbe, Vbc;    
real eVb2c2, eVb2e1, eVb1e1, eVb1b2, eVb1c4, eVbc3, eVsc1;    
real eVb1c4VDC, eVb2c2VDC, eVbc3VDC, eVb2c1VDC;  
  

  
real dxa, sqr_arg;  
real eps2, x2;  
real alpha1, vdif, Ic1c2_Iqs, gp0_help;  
real EmEav_Em, Vb2e1Vfe, termE, termC;  
real Vex_bias;  
real eps_VDC, a_VDE, a_VDC; 

real expl, tmpExp, tmpV;



real a_VDS;  

 

 
real common; 
real powerREC, powerRBC, powerRCCxx, powerRCCex, powerRCCin, powerRBV; 
real powerCCS;  
real powerFBCS, powerFBC1fB1, exponentFBC1fB2, powerFBC1fB2; 
real powerEBSCS, powerEBSC1f; 
real powerRBCS, powerRBC1f; 
real powerExCS, powerExCSMOD, powerExC1f, powerExC1fMOD; 


real powerSubsCS_B1S, powerSubsCS_BS; 



real twoqIavl, cor_exp_1, cor_exp_2, powerCCS_A; 
 
# 35 "admsva/mextram.va"
# 1 "opvars.inc"





 
 
 


 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 


 
 
 
 


 
 


real dydx, dydz, gpi;
real gammax, gammay, gammaz, gbfx, gbfy, gbfz, alpha_ft;
real rx, ry, rz, rb1b2, rex, xrex, taut;

# 36 "admsva/mextram.va"

analog begin 
  





   
# 1 "initialize.inc"


     
   
if (TYPE == 1) begin  
  
   An = 7.03e7;   
   Bn = 1.23e8;   
  
end else begin  
                          
   An = 1.58e8;   
   Bn = 2.04e8;   
  
end  
 
Xext1 = 1.0 - XEXT; 

    


   CTH_M  = CTH   * MULT;    


   CBEO_M = CBEO  * MULT;  
   CBCO_M = CBCO  * MULT;  

   invMULT    = 1.0 / MULT;   
   SCRCV_M    = SCRCV    * invMULT;    

   KF_M     = KF  * pow(MULT, 1.0 - AF);   
   KFN_M    = KFN * pow(MULT, 1.0 - (2.0 * (MLF - 1.0) + AF * (2.0 - MLF)));   

# 46 "admsva/mextram.va"     
# 1 "tscaling.inc"

      
   

   Tki = V(dt);                      
   
   if (Tki < 0.0) begin  
       Tki = - ln(1.0 - Tki);  
   end 
    if ( Tki <  200.0)          Vdt =  Tki;      else          Vdt =  200.0 + ln(1.0 + ( Tki -  200.0));      Vdt=Vdt;

# 15 "tscaling.inc"
                                       
   
   Trk = TREF +  273.15;   
    

   Tk   = Trk + DTA + Vdt;     
   Tamb = Trk + DTA;  
# 26 "tscaling.inc"
    
   tN  = Tk / Trk;    
   Vt  =  8.61708691805812512584e-5 * Tk;    
   Vtr =  8.61708691805812512584e-5 * Trk;   
   VtINV = 1.0 / Vt;   
   VtrINV = 1.0 / Vtr;     
   VdtINV = VtINV - VtrINV;     
   
   
   
   UdeT = -3.0 * Vt * ln(tN) + VDE * tN + (1.0 - tN) * VGB;   
    dxa = (  0.05 -  UdeT) / ( Vt);     if (  0.05 <  UdeT)          VDE_T =  UdeT +  Vt * ln(1.0 + exp(dxa));     else          VDE_T =   0.05  +  Vt * ln(1.0 + exp(-dxa));     VDE_T=VDE_T;  
   
   UdcT = -3.0 * Vt * ln(tN) + VDC * tN + (1.0 - tN) * VGC;   
    dxa = (  0.05 -  UdcT) / ( Vt);     if (  0.05 <  UdcT)          VDC_T =  UdcT +  Vt * ln(1.0 + exp(dxa));     else          VDC_T =   0.05  +  Vt * ln(1.0 + exp(-dxa));     VDC_T=VDC_T;  
 

   UdsT = -3.0 * Vt * ln(tN) + VDS * tN + (1.0 - tN) * VGS;   
    dxa = (  0.05 -  UdsT) / ( Vt);     if (  0.05 <  UdsT)          VDS_T =  UdsT +  Vt * ln(1.0 + exp(dxa));     else          VDS_T =   0.05  +  Vt * ln(1.0 + exp(-dxa));     VDS_T=VDS_T;  

        
   CJE_T = CJE * pow(VDE / VDE_T, PE);   


   CJS_T = CJS * pow(VDS / VDS_T, PS);   

                                         
   CJCscale = ((1.0 - XP) * pow(VDC / VDC_T, PC) + XP);   
   CJCscaleINV = 1.0 / CJCscale;    
   
   CJC_T = CJC * CJCscale;   
   XP_T  = XP  * CJCscaleINV;   
      
   
      
   RE_T  = RE  * pow(tN, AE);   
   RBV_T = RBV * pow(tN, AB - AQBO);   
   RBC_T = RBC * pow(tN, AEX);   


   RCCxx_T = RCC * pow(tN, AC);   
   RCCex_T = RCBLX * pow(tN, ACBL);   
   RCCin_T = RCBLI * pow(tN, ACBL);   

   RCV_T = RCV * pow(tN, AEPI);    
   
   
      
   BF_T  = BF  * pow(tN, AE - AB - AQBO) * exp(-DVGBF * VdtINV);    
   BRI_T = BRI * exp(-DVGBR * VdtINV);    
   
   
   
   IS_T  = IS  * pow(tN, 4.0 - AB - AQBO + DAIS) * exp(-VGB * VdtINV);    
   IK_T  = IK  * pow(tN, 1.0 - AB);   
   IBF_T = IBF * pow(tN, 6.0 - 2.0 * MLF) * exp(-VGJ * VdtINV / MLF);   
   IBR_T = IBR * tN * tN * exp(-VGC * VdtINV / 2.0);   
   VEF_T = VEF * pow(tN, AQBO) * CJCscaleINV;   
   VER_T = VER * pow(tN, AQBO) * pow(VDE / VDE_T, -PE);   


   ISS_T = ISS * pow(tN, 4.0 - AS) * exp(-VGS * VdtINV);    
   if ((ISS_T > 0.0))    
      IKS_T = IKS * pow(tN, 1.0 - AS) * (IS_T / IS) * (ISS / ISS_T);   
   else    
      IKS_T = IKS * pow(tN, 1.0 - AS);   

       
   
   
   TAUE_T = TAUE * pow(tN, AB - 2.0) * exp(-DVGTE * VdtINV);   
   TAUB_T = TAUB * pow(tN, AQBO + AB - 1.0);   
   TEPI_T = TEPI * pow(tN, AEPI - 1.0);    
   TAUR_T = TAUR * (TAUB_T + TEPI_T) / (TAUB + TEPI);    
      
   
                             
   Tk300 = Tk - 300.0;

   if (Tk < 525.0)
    begin
     BnT = Bn * (1.0 + 7.2e-4 * Tk300 - 1.6e-6 * Tk300 * Tk300) ;   
    end
   else
    begin
     BnT = Bn * 1.081 ;
    end
  
   
   
   DEG_T = DEG * pow(tN, AQBO);      
   

  
 
   RTH_Tamb = RTH * pow(Tamb / Trk, ATH); 

   

     
   IS_TM  = IS_T  * MULT;       
   IK_TM  = IK_T  * MULT;   
   IBF_TM = IBF_T * MULT;    
   IBR_TM = IBR_T * MULT;    
   IHC_M  = IHC   * MULT;    

   ISS_TM = ISS_T * MULT;    
   IKS_TM = IKS_T * MULT;    

   CJE_TM = CJE_T * MULT;    
   CJC_TM = CJC_T * MULT;    


   CJS_TM = CJS_T * MULT;    

                
   RE_TM      = RE_T     * invMULT;       
   RBC_TM     = RBC_T    * invMULT;   
   RBV_TM     = RBV_T    * invMULT;    

   RCCxx_TM   = RCCxx_T  * invMULT;    
   RCCex_TM   = RCCex_T  * invMULT;    
   RCCin_TM   = RCCin_T  * invMULT;    
   RCV_TM     = RCV_T    * invMULT;    
 


   if (RCC > 0.0) 
    begin 
     GCCxx_TM = 1.0 / RCCxx_TM ;   
    end
   else
    begin
     GCCxx_TM = 0 ;   
    end 

   if (RCBLX > 0.0) 
    begin 
     GCCex_TM = 1.0 / RCCex_TM ;   
    end
   else
    begin
     GCCex_TM = 0 ;   
    end 

   if (RCBLI > 0.0) 
    begin 
     GCCin_TM = 1.0 / RCCin_TM ;   
    end
   else
    begin
     GCCin_TM = 0 ;   
    end 


   RTH_Tamb_M = RTH_Tamb * invMULT;    

# 47 "admsva/mextram.va"



# 1 "evaluate.inc"

  
begin  

  
   Vb2c1 = TYPE * V(b2, c1);  
   Vb2c2 = TYPE * V(b2, c2);  
   Vb2e1 = TYPE * V(b2, e1);  
   Vb1e1 = TYPE * V(b1, e1);  
   Vb1b2 = TYPE * V(b1, b2);  

   Vsc1  = TYPE * V(s,  c1);  

   Vc1c2 = TYPE * V(c1, c2);  
   Vee1  = TYPE * V(e,  e1);  
   Vbb1  = TYPE * V(b,  b1);  
   Vbe   = TYPE * V(b,  e);  
   Vbc   = TYPE * V(b,  c);   







if (RCBLX > 0.0)
 begin
  if (RCBLI > 0.0)
    begin
     Vc4c1 = TYPE * V(c4, c1);  
     Vc3c4 = TYPE * V(c3, c4);  
    end
   else
    begin
     Vc4c1 = 0 ;  
     Vc3c4 = TYPE * V(c3, c1);  
    end
 end
else
 begin
  if (RCBLI > 0.0)
    begin
     Vc4c1 = TYPE * V(c4, c1);  
     Vc3c4 = 0 ;  
    end
   else
    begin
     Vc4c1 = 0 ;  
     Vc3c4 = 0 ;  
    end
 end

   Vb1c4 = Vb1b2 + Vb2c2 - Vc1c2 - Vc4c1 ;  
   Vcc3  = - Vbc + Vbb1 + Vb1c4 - Vc3c4 ;  
   Vbc3  = Vbc + Vcc3 ;


Vsc4 = Vsc1 - Vc4c1 ;
Vsc3 = Vsc4 - Vc3c4 ;




  
    if (Vb2c2 * VtINV <  200.0)          eVb2c2 = exp(Vb2c2 * VtINV);      else begin          expl = exp( 200.0);          eVb2c2 = expl  * (1.0 + (Vb2c2 * VtINV -  200.0));      end  
    if (Vb2e1 * VtINV <  200.0)          eVb2e1 = exp(Vb2e1 * VtINV);      else begin          expl = exp( 200.0);          eVb2e1 = expl  * (1.0 + (Vb2e1 * VtINV -  200.0));      end    
    if (Vb1e1 * VtINV <  200.0)          eVb1e1 = exp(Vb1e1 * VtINV);      else begin          expl = exp( 200.0);          eVb1e1 = expl  * (1.0 + (Vb1e1 * VtINV -  200.0));      end   
    if (Vb1c4 * VtINV <  200.0)          eVb1c4 = exp(Vb1c4 * VtINV);      else begin          expl = exp( 200.0);          eVb1c4 = expl  * (1.0 + (Vb1c4 * VtINV -  200.0));      end  
    if (Vb1b2 * VtINV <  200.0)          eVb1b2 = exp(Vb1b2 * VtINV);      else begin          expl = exp( 200.0);          eVb1b2 = expl  * (1.0 + (Vb1b2 * VtINV -  200.0));      end  
    if (Vbc3  * VtINV <  200.0)          eVbc3 = exp(Vbc3  * VtINV);      else begin          expl = exp( 200.0);          eVbc3 = expl  * (1.0 + (Vbc3  * VtINV -  200.0));      end  

    if (Vsc1  * VtINV <  200.0)          eVsc1 = exp(Vsc1  * VtINV);      else begin          expl = exp( 200.0);          eVsc1 = expl  * (1.0 + (Vsc1  * VtINV -  200.0));      end  

     
    if ((Vbc3  - VDC_T) * VtINV <  200.0)          eVbc3VDC = exp((Vbc3  - VDC_T) * VtINV);      else begin          expl = exp( 200.0);          eVbc3VDC = expl  * (1.0 + ((Vbc3  - VDC_T) * VtINV -  200.0));      end                      
    if ((Vb1c4 - VDC_T) * VtINV <  200.0)          eVb1c4VDC = exp((Vb1c4 - VDC_T) * VtINV);      else begin          expl = exp( 200.0);          eVb1c4VDC = expl  * (1.0 + ((Vb1c4 - VDC_T) * VtINV -  200.0));      end  
    if ((Vb2c2 - VDC_T) * VtINV <  200.0)          eVb2c2VDC = exp((Vb2c2 - VDC_T) * VtINV);      else begin          expl = exp( 200.0);          eVb2c2VDC = expl  * (1.0 + ((Vb2c2 - VDC_T) * VtINV -  200.0));      end  
    if ((Vb2c1 - VDC_T) * VtINV <  200.0)          eVb2c1VDC = exp((Vb2c1 - VDC_T) * VtINV);      else begin          expl = exp( 200.0);          eVb2c1VDC = expl  * (1.0 + ((Vb2c1 - VDC_T) * VtINV -  200.0));      end  
  

  
   
   
   K0 = sqrt(1.0 + 4.0 * eVb2c2VDC);   
   Kw = sqrt(1.0 + 4.0 * eVb2c1VDC);    
   pW = 2.0 *  eVb2c1VDC / (1.0 + Kw);   
   if (pW <  1.0e-40) pW = 0; 
   Ec = Vt * (K0 - Kw - ln((K0 + 1.0) / (Kw + 1.0)) );    
   Ic1c2 =  (Ec + Vc1c2) / RCV_TM;     
  
   if (Ic1c2 > 0.0) begin   
      
      if (Vb2c1 < 100.0)          tmpV = Vb2c1;      else          tmpV = 100.0 + ln(1.0 + (Vb2c1 - 100.0));      tmpV=tmpV;
     Vqs_th = VDC_T + 2.0 * Vt *    
              ln(0.5 * Ic1c2 * RCV_TM * VtINV + 1.0) - tmpV;     
     eps_VDC = 0.2 * VDC_T;  
      eps2 =  eps_VDC *  eps_VDC;     x2 =  Vqs_th *  Vqs_th;     if ( Vqs_th < 0.0)       Vqs = 0.5 * eps2 / (sqrt(x2 + eps2) -  Vqs_th);     else       Vqs = 0.5 * (sqrt(x2 + eps2) +  Vqs_th);     Vqs=Vqs;  
     Iqs = Vqs * (Vqs + IHC_M * SCRCV_M) / (SCRCV_M * (Vqs + IHC_M * RCV_TM));  
  
     Ic1c2_Iqs = Ic1c2 / Iqs;  
      dxa = ( Ic1c2_Iqs -  1.0) / ( AXI);     if ( Ic1c2_Iqs <  1.0)          alpha1 =  1.0 +  AXI * ln(1.0 + exp(dxa));     else          alpha1 =  Ic1c2_Iqs  +  AXI * ln(1.0 + exp(-dxa));     alpha1=alpha1;    
     alpha = alpha1 / (1.0 + AXI * ln(1.0 + exp(-1.0 / AXI)));   
     vyi = Vqs / (IHC_M * SCRCV_M);    
     yi = (1.0 + sqrt(1.0 + 4.0 * alpha * vyi * (1.0 + vyi))) /   
          (2.0 * alpha * (1.0 + vyi));    
  
     xi_w = 1.0 - yi / (1.0 + pW * yi);   
     gp0 = 0.5 * Ic1c2 * RCV_TM * xi_w * VtINV;    
     
     gp0_help = 2.0 * gp0 + pW * (pW + gp0 + 1.0);  
     gp02 = 0.5 * (gp0 - 1.0);   
     sqr_arg = gp02 * gp02 + gp0_help;  
     if (gp0 >= 1.0)  
        p0star =  gp02 + sqrt(sqr_arg);    
     else  
        p0star = gp0_help / (sqrt(sqr_arg) - gp02);  
     if (p0star <  1.0e-40) p0star = 0.0; 
 
 
     eVb2c2star = p0star * (p0star + 1.0) * exp(VDC_T * VtINV);    
     B1 = 0.5 * SCRCV_M * (Ic1c2 - IHC_M);   
     B2 = SCRCV_M * RCV_TM * IHC_M * Ic1c2;    
     Vxi0 = B1 + sqrt(B1 * B1 + B2);    
     Vch = VDC_T * (0.1 + 2.0 * Ic1c2 / (Ic1c2 + Iqs));     
     Icap = IHC_M * Ic1c2 / (IHC_M + Ic1c2);   
     Icap_IHC = IHC_M / (IHC_M + Ic1c2);  
      
   end else begin    
         
     p0star = 2.0 * eVb2c2VDC / (1.0 + K0);    
     eVb2c2star = eVb2c2;   
     if ((abs(Vc1c2) < 1.0e-5 * Vt) ||   
         (abs(Ec) <  1.0e-40 * Vt * (K0 + Kw))) 
        begin   
          pav = 0.5 * (p0star + pW);   
          xi_w = pav / (pav + 1.0);   
        end

     else 
        begin   
          xi_w = Ec / (Ec + Vb2c2 - Vb2c1);    
        end   
   
     Vxi0 = Vc1c2;    
     Vch = 0.1 * VDC_T;                    
     Icap = Ic1c2;   
     Icap_IHC = 1.0 - Icap / IHC_M;  
   
   end    
   
   
    
   Vfe = VDE_T * (1.0 - pow( 3.0 , -1.0 / PE));   
   a_VDE = 0.1 * VDE_T;  
    dxa = ( Vb2e1 -  Vfe) / ( a_VDE);     if ( Vb2e1 <  Vfe)          Vje =  Vb2e1  -  a_VDE * ln(1.0 + exp(dxa));     else          Vje =  Vfe -  a_VDE * ln(1.0 + exp(-dxa));     Vje=Vje;  
   Vte = VDE_T / (1.0 - PE) * (1.0 - pow(1.0 - Vje / VDE_T, 1.0 - PE)) +   
         3.0 * (Vb2e1 - Vje);   
      
   
    
   Vjunc = Vb2c1 + Vxi0;   
   bjc = ( 2.0 - XP_T) / (1.0 - XP_T);   
   Vfc = VDC_T * (1.0 - pow(bjc, -1.0 / PC));    
    dxa = ( Vjunc -  Vfc) / ( Vch);     if ( Vjunc <  Vfc)          Vjc =  Vjunc  -  Vch * ln(1.0 + exp(dxa));     else          Vjc =  Vfc -  Vch * ln(1.0 + exp(-dxa));     Vjc=Vjc;  
   fI = pow(Icap_IHC, MC);    
   Vcv = VDC_T / (1.0 - PC) * (1.0 - fI * pow(1.0 - Vjc / VDC_T, 1.0 - PC)) +   
         fI * bjc * (Vjunc - Vjc);    
   Vtc = (1.0 - XP_T) * Vcv + XP_T * Vb2c1;    
  
   
    
   If0 = 4.0 * IS_TM / IK_TM;  
   f1 =  If0 * eVb2e1;    
   n0 =  f1 / (1.0 + sqrt(1.0 + f1));    
   f2 =  If0 * eVb2c2star;      
   nB =  f2 / (1.0 + sqrt(1.0 + f2));    
  
   if (DEG == 0.0) 
        q0I = 1.0 + Vte / VER_T + Vtc / VEF_T;    
   else 
      begin  
        termE = (Vte / VER_T + 1.0) * DEG_T * VtINV;  
        termC = -Vtc / VEF_T * DEG_T * VtINV;  
        q0I = (exp(termE) - exp(termC)) /   
              (exp(DEG_T * VtINV) - 1.0);  
      end  
  
    eps2 =  0.1 *  0.1;     x2 =  q0I *  q0I;     if ( q0I < 0.0)       q1I = 0.5 * eps2 / (sqrt(x2 + eps2) -  q0I);     else       q1I = 0.5 * (sqrt(x2 + eps2) +  q0I);     q1I=q1I;   
   qBI = q1I * (1.0 + 0.5 * (n0 + nB));    
   
   Ir = IS_TM *  eVb2c2star;    
   If = IS_TM * eVb2e1;   
   In = (If - Ir) / qBI;    
    
   
                
   Ibf0 = IS_TM / BF_T;     
   if (XREC == 0.0)  
      Ib1 = (1.0 - XIBI) * Ibf0 * (eVb2e1 - 1.0);   
   else  
      Ib1 = (1.0 - XIBI) * Ibf0 * ((1.0 - XREC) * (eVb2e1 - 1.0) +  
            XREC * (eVb2e1 + eVb2c2star - 2.0) * (1.0 + Vtc / VEF_T));    
  
   Ib1_s = XIBI * Ibf0 * (eVb1e1 - 1.0);   
    if (Vb2e1 * VtINV / MLF <  200.0)          tmpExp = exp(Vb2e1 * VtINV / MLF);      else begin          expl = exp( 200.0);          tmpExp = expl  * (1.0 + (Vb2e1 * VtINV / MLF -  200.0));      end
   Ib2 = IBF_TM * (tmpExp - 1.0) + _circuit_gmin * Vb2e1;       
    if (0.5 * Vb1c4 * VtINV <  200.0)          tmpExp = exp(0.5 * Vb1c4 * VtINV);      else begin          expl = exp( 200.0);          tmpExp = expl  * (1.0 + (0.5 * Vb1c4 * VtINV -  200.0));      end
   Ib3 = IBR_TM * (eVb1c4 - 1.0) /   
         (tmpExp + exp(0.5 * VLR * VtINV)) +    
         _circuit_gmin  * Vb1c4;    
      
   
  
   g1 = If0 * eVb1c4;                   
   g2 = 4.0 * eVb1c4VDC;     
   nBex = g1 / (1.0 + sqrt(1.0 + g1));    
   pWex = g2 / (1.0 + sqrt(1.0 + g2));    
   Iex = (1.0 / BRI_T) * (0.5 * IK_TM * nBex - IS_TM);    


   Isub = 2.0 * ISS_TM * (eVb1c4 - 1.0) /   
          (1.0 + sqrt(1.0 + 4.0 * (IS_TM / IKS_TM) * eVb1c4));     
   Isf =  ISS_TM * (eVsc1 - 1.0);   

  
   XIex =0.0; 


   XIsub = 0.0;    


   if (EXMOD == 1) 
    begin   
  
      Iex =   Iex *  Xext1;     


      Isub  = Isub * Xext1;    

  
      Xg1 = If0 * eVbc3;    
      XnBex = Xg1 / (1.0 + sqrt(1.0 + Xg1));    
      XIMex = XEXT * (0.5 * IK_TM * XnBex - IS_TM) / BRI_T;   


      XIMsub = XEXT * 2.0 * ISS_TM * (eVbc3 - 1.0) /   
               (1.0 + sqrt(1.0 + 4.0 * IS_T / IKS_T * eVbc3));    
      Vex_bias = XEXT * (IS_TM / BRI_T + ISS_TM) * RCCxx_TM;  
# 253 "evaluate.inc"
      
      Vex = Vt * (2.0 - ln( Vex_bias * VtINV));    
      vdif = Vbc3 - Vex;  
       eps2 =  0.11 *  0.11;     x2 =  vdif *  vdif;     if ( vdif < 0.0)       VBex = 0.5 * eps2 / (sqrt(x2 + eps2) -  vdif);     else       VBex = 0.5 * (sqrt(x2 + eps2) +  vdif);     VBex=VBex;  
  
      Fex = VBex /(Vex_bias + (XIMex + XIMsub) * RCCxx_TM + VBex);     
      XIex = Fex * XIMex;   


      XIsub = Fex * XIMsub;     

    end     
   else
    begin
     Fex = 0;
     XnBex = 0 ;
    end

   
        
   q0Q = 1.0 + Vte / VER_T + Vtc / VEF_T;    
    eps2 =  0.1 *  0.1;     x2 =  q0Q *  q0Q;     if ( q0Q < 0.0)       q1Q = 0.5 * eps2 / (sqrt(x2 + eps2) -  q0Q);     else       q1Q = 0.5 * (sqrt(x2 + eps2) +  q0Q);     q1Q=q1Q;   
   qBQ = q1Q * (1.0 + 0.5 * (n0 + nB));    
  
   Rb2 = 3.0 * RBV_TM / qBQ;   
   Ib1b2 =  (2.0 * Vt * (eVb1b2 - 1.0) + Vb1b2) / Rb2;   
   
   
      
   Iavl = 0.0;  
   Gem  = 0.0;  
   if ((Ic1c2 > 0.0) && (Vb2c1 < VDC_T)) begin   
  
      dEdx0 = 2.0 * VAVL / (WAVL * WAVL);    
      sqr_arg = (VDC_T - Vb2c1) / Icap_IHC;  
      xd = sqrt(2.0 * sqr_arg / dEdx0);      
      if (EXAVL == 0.0) 
         Weff = WAVL;   
      else 
         begin            
           xi_w1 = 1.0 - 0.5 * xi_w;
           Weff = WAVL * xi_w1 * xi_w1;    
         end
      Wd = xd * Weff / sqrt(xd * xd + Weff * Weff);    
      Eav = (VDC_T - Vb2c1) / Wd;   
      E0 = Eav + 0.5 * Wd * dEdx0 * Icap_IHC;   
      
      if (EXAVL == 0)  
         Em = E0;   
      else 
         begin               
           SHw = 1.0 + 2.0 * SFH * (1.0 + 2.0 * xi_w);    
           Efi = (1.0 + SFH) / (1.0 + 2.0 * SFH);   
           Ew = Eav - 0.5 * Wd * dEdx0 * (Efi - Ic1c2 / (IHC_M * SHw));   
           sqr_arg = (Ew - E0) * (Ew - E0) + 0.1 * Eav * Eav * Icap / IHC_M;   
           Em = 0.5 * (Ew + E0 + sqrt(sqr_arg));  
         end   
   
      EmEav_Em = (Em - Eav) / Em;   
      if (abs(EmEav_Em) >  1.0e-7) 
         begin   
           lambda = 0.5 * Wd / EmEav_Em;    
           Gem = An / BnT * Em * lambda *   
                (exp(-BnT / Em) - exp(-BnT / Em * (1.0 + Weff / lambda)) );   
         end
      else    
         Gem = An * Weff * exp(-BnT / Em);   
   
      Gmax = Vt / (Ic1c2 * (RBC_TM + Rb2)) +  qBI / BF_T +   
             RE_TM / (RBC_TM + Rb2);   
      Iavl = Ic1c2 * Gem  / (Gem +Gem / Gmax + 1.0);   
   end    

   if (eVb2c2star > 0.0)   
      Vb2c2star = Vt * ln(eVb2c2star);   
   else  
      Vb2c2star = Vb2c2;  
    

   
 


   power =  In * (Vb2e1 - Vb2c2star) +    
            Ic1c2 * (Vb2c2star - Vb2c1) -   
            Iavl  * Vb2c2star +   
            Vee1  * Vee1  / RE_TM +   
            Vcc3  * Vcc3  * GCCxx_TM +   
            Vc3c4 * Vc3c4 * GCCex_TM +   
            Vc4c1 * Vc4c1 * GCCin_TM +   
            Vbb1  * Vbb1  / RBC_TM +   
            Ib1b2 * Vb1b2 +   
            (Ib1 + Ib2) * Vb2e1 +   
            Ib1_s * Vb1e1 +   

            (Iex + Ib3) * Vb1c4 + XIex  * Vbc3 + 
              Isub * (Vb1c4 - Vsc4) +   
             XIsub * (Vbc3 - Vsc3) +   
              Isf * Vsc1;   
# 355 "evaluate.inc"
    



   
   
   Qte = (1.0 - XCJE) * CJE_TM * Vte;    
    dxa = ( Vb1e1 -  Vfe) / ( a_VDE);     if ( Vb1e1 <  Vfe)          Vje_s =  Vb1e1  -  a_VDE * ln(1.0 + exp(dxa));     else          Vje_s =  Vfe -  a_VDE * ln(1.0 + exp(-dxa));     Vje_s=Vje_s;  
   Qte_s = XCJE * CJE_TM * (VDE_T / (1.0 - PE) *    
           (1.0 - pow(1.0 - Vje_s / VDE_T, 1.0 - PE)) +    
             3.0 * (Vb1e1 - Vje_s));    
       
   Qtc = XCJC * CJC_TM * Vtc;    
   Qb0 = TAUB_T * IK_TM;   
   Qbe_qs = 0.5 * Qb0 * n0 * q1Q;   
   Qbc_qs = 0.5 * Qb0 * nB * q1Q;    
    
   a_VDC = 0.1 * VDC_T;  
    dxa = ( Vb1c4 -  Vfc) / ( a_VDC);     if ( Vb1c4 <  Vfc)          Vjcex =  Vb1c4  -  a_VDC * ln(1.0 + exp(dxa));     else          Vjcex =  Vfc -  a_VDC * ln(1.0 + exp(-dxa));     Vjcex=Vjcex;  
   Vtexv = VDC_T / (1.0 - PC) * (1.0 - pow(1.0 - Vjcex / VDC_T, 1.0 - PC)) +   
           bjc * (Vb1c4 - Vjcex);   
   Qtex = CJC_TM * ((1.0 - XP_T) * Vtexv + XP_T * Vb1c4) *    
          (1.0 - XCJC) * (1.0 - XEXT);      
  
    dxa = ( Vbc3 -  Vfc) / ( a_VDC);     if ( Vbc3 <  Vfc)          XVjcex =  Vbc3  -  a_VDC * ln(1.0 + exp(dxa));     else          XVjcex =  Vfc -  a_VDC * ln(1.0 + exp(-dxa));     XVjcex=XVjcex;  
   XVtexv = VDC_T / (1.0 - PC) * (1.0 - pow(1.0 - XVjcex / VDC_T, 1.0 - PC)) +   
            bjc * (Vbc3 - XVjcex);   
   XQtex = CJC_TM * ((1.0 - XP_T) * XVtexv + XP_T * Vbc3) *    
           (1.0 - XCJC) * XEXT;    
    

   a_VDS = 0.1 * VDS_T;  
   Vfs = VDS_T * (1.0 - pow( 2.0 , -1.0 / PS));   
    dxa = ( Vsc1 -  Vfs) / ( a_VDS);     if ( Vsc1 <  Vfs)          Vjs =  Vsc1  -  a_VDS * ln(1.0 + exp(dxa));     else          Vjs =  Vfs -  a_VDS * ln(1.0 + exp(-dxa));     Vjs=Vjs;  
   Qts = CJS_TM * (VDS_T / (1.0 - PS) *    
         (1.0 - pow(1.0 - Vjs / VDS_T, 1.0 - PS)) +   2.0 * (Vsc1 - Vjs));   

  
   Qe0 = TAUE_T * IK_TM * pow(IS_TM / IK_TM, 1.0 / MTAU);   
    if (Vb2e1 / (MTAU * Vt) <  200.0)          tmpExp = exp(Vb2e1 / (MTAU * Vt));      else begin          expl = exp( 200.0);          tmpExp = expl  * (1.0 + (Vb2e1 / (MTAU * Vt) -  200.0));      end
   Qe = Qe0 * (tmpExp - 1.0);   
                                                                 
   Qepi0 = 4.0 * TEPI_T * Vt / RCV_TM;   
   Qepi = 0.5 * Qepi0 * xi_w * (p0star + pW + 2.0);   
                                                             
   Qex = TAUR_T * 0.5 * (Qb0 * nBex + Qepi0 * pWex) / (TAUB_T + TEPI_T);        
   XQex = 0.0;   
  
   if (EXMOD == 1) begin       
  
      Qex = Qex * (1.0 - XEXT);    
      Xg2 = 4.0 * eVbc3VDC;    
      XpWex = Xg2 / (1.0 + sqrt(1.0 + Xg2));    
      XQex = 0.5 * Fex * XEXT * TAUR_T *   
             (Qb0 * XnBex + Qepi0 * XpWex) / (TAUB_T + TEPI_T);   
  
   end    
  
   Qb1b2 = 0.0;  
   if (EXPHI == 1) 
      begin  
        dVteVje = pow(1.0 - Vje / VDE_T, -PE) -  3.0;  
        Vb2e1Vfe = (Vb2e1 - Vfe) / a_VDE;  
        if (Vb2e1Vfe < 0.0)  
           dVjeVb2e1 = 1.0 / (1.0 + exp(Vb2e1Vfe));  
        else  
           dVjeVb2e1 = exp(- Vb2e1Vfe) / (1.0 + exp(- Vb2e1Vfe));  
       
        dVteVb2e1 = dVteVje * dVjeVb2e1 +  3.0;   
        dQteVb2e1 = (1.0 - XCJE) * CJE_TM * dVteVb2e1;  
  
        dn0Vb2e1 = If0 * eVb2e1 * VtINV * (0.5 / sqrt(1.0 + f1));  
        dQbeVb2e1 = 0.5 * Qb0 * q1Q * dn0Vb2e1;   
  
        dQeVb2e1 = (Qe + Qe0) / (MTAU * Vt);   
   
        Qb1b2 = 0.2 * Vb1b2 * (dQteVb2e1 + dQbeVb2e1 + dQeVb2e1);   
  
        Qbc = Qbe_qs / 3.0 + Qbc_qs;  
        Qbe = 2.0 * Qbe_qs / 3.0;  
      end  
    else
      begin
        Qbe = Qbe_qs;
        Qbc = Qbc_qs;
      end
      


  
   
   I(c1, c2) <+ TYPE * Ic1c2;   
   I(c2, e1) <+ TYPE * In;   
   I(b1, e1) <+ TYPE * Ib1_s;    
   I(b2, e1) <+ TYPE * (Ib1 + Ib2);   

   I(b1, s)  <+ TYPE * Isub;   
   I(b,  s)  <+ TYPE * XIsub;    
   I(s,  c1) <+ TYPE * Isf;   

   I(b1, b2) <+ TYPE * Ib1b2;    
   I(b2, c2) <+ TYPE * (-1.0 * Iavl);  
   I(e,  e1) <+ TYPE * Vee1 / RE_TM;   
   I(b,  b1) <+ TYPE * Vbb1 / RBC_TM;


   
   I(dt) <+ V(dt) / RTH_Tamb_M;     
   I(dt) <+ ddt(CTH_M * V(dt));   
   I(dt) <+ -1.0 *  power;  

    
   
   I(noi, e1)    <+ V(noi, e1); 
   cor_exp_1 = sqrt(1.0 + 2.0 * Gem) * V(noi,e1); 
   I(b2, e1) <+ cor_exp_1; 
   cor_exp_2 = (2.0 + 2.0 * Gem) / sqrt(1.0 + 2.0 * Gem) * V(noi, e1); 
   I(e1, c2) <+ cor_exp_2; 
 
   
   I(b2, e1) <+ ddt(TYPE * (Qte + Qbe + Qe));   
   I(b1, e1) <+ ddt(TYPE * (Qte_s));   
   I(b2, c2) <+ ddt(TYPE * (Qtc + Qbc + Qepi));   

   I(s,  c1) <+ ddt(TYPE * Qts);   

   I(b1, b2) <+ ddt(TYPE * Qb1b2);  
   I(b,   e) <+ ddt(TYPE * CBEO_M * Vbe);   
   I(b,   c) <+ ddt(TYPE * CBCO_M * Vbc);  
 
   end  








if (RCBLX > 0.0)
 begin
  I(b,  c3) <+ TYPE * XIex;   
  I(c,  c3) <+ TYPE * Vcc3  * GCCxx_TM ;
  I(b,  c3) <+ ddt(TYPE * (XQtex + XQex));    
  if (RCBLI > 0.0)
   begin
     I(c4, c1) <+ TYPE * Vc4c1 * GCCin_TM;    
     I(b1, c4) <+ TYPE * (Ib3 + Iex);    
     I(c3, c4) <+ TYPE * Vc3c4 * GCCex_TM ;    
     I(b1, c4) <+ ddt(TYPE * (Qtex + Qex));        
   end
  else
   begin
     V(c4, c1) <+ 0.0 ;    
     I(b1, c1) <+ TYPE * (Ib3 + Iex);
     I(b1, c1) <+ ddt(TYPE * (Qtex + Qex));            
     I(c3, c1) <+ TYPE * Vc3c4 * GCCex_TM ;    
   end
 end
else
 begin
  V(c3, c4) <+ 0 ;    
       if (RCBLI > 0.0)
          begin
            I(b,  c4) <+ TYPE * XIex;   
            I(c,  c4) <+ TYPE * Vcc3  * GCCxx_TM ;
            I(c4, c1) <+ TYPE * Vc4c1 * GCCin_TM;    
            I(b1, c4) <+ TYPE * (Ib3 + Iex);    
            I(b1, c4) <+ ddt(TYPE * (Qtex + Qex)); 
            I(b,  c4) <+ ddt(TYPE * (XQtex + XQex));    
          end  
       else
          begin 
            I(b,  c1) <+ TYPE * XIex;   
            I(c,  c1) <+ TYPE * Vcc3  * GCCxx_TM ;
            V(c4, c1) <+ 0.0 ;    
            I(b1, c1) <+ TYPE * (Ib3 + Iex);
            I(b1, c1) <+ ddt(TYPE * (Qtex + Qex));
            I(b,  c1) <+ ddt(TYPE * (XQtex + XQex));                
            I(c3, c1) <+ TYPE * Vc3c4 * GCCex_TM ;
          end
 end
 

  
 @(noise) begin  
 
   
   common = 4.0 *  1.3806226e-23 * Tk;  
   powerREC = common / RE_TM;  
   powerRBC = common / RBC_TM; 
 
   powerRCCxx = common * GCCxx_TM; 
   powerRCCex = common * GCCex_TM; 
   powerRCCin = common * GCCin_TM; 
   powerRBV = common / Rb2 * (4.0 * eVb1b2 + 5.0) / 3.0; 
 
   
   powerCCS = 2.0 *  1.6021918e-19 * (If + Ir) / qBI; 
 
   
   powerFBCS = 2.0 *  1.6021918e-19 * (abs(Ib1) + abs(Ib2)); 
   powerFBC1fB1 = (1.0 - XIBI) * pow((abs(Ib1) / (1 - XIBI)), AF) * KF_M; 
   exponentFBC1fB2 = (2.0 * (MLF - 1.0)) + (AF * (2.0 - MLF)); 
   powerFBC1fB2 = KFN_M * pow(abs(Ib2), exponentFBC1fB2); 
 
  
   powerEBSCS = 2.0 *  1.6021918e-19 * abs(Ib1_s); 
   if (XIBI == 0)  
       powerEBSC1f = 0.0; 
   else  
       powerEBSC1f = KF_M * XIBI * pow((abs(Ib1_s / XIBI)), AF); 
 
  
   powerRBCS = 2.0 *  1.6021918e-19 * abs(Ib3); 
   powerRBC1f = KF_M * pow(abs(Ib3), AF); 
  
   
   powerExCS = 2.0 *  1.6021918e-19 * abs(Iex); 
   powerExC1f = KF_M * (1 - (EXMOD * XEXT)) *  
                pow((abs(Iex) / (1 - (EXMOD * XEXT))), AF); 
   powerExCSMOD = 2.0 *  1.6021918e-19 * abs(XIex) * EXMOD; 
   if (XEXT == 0.0)  
       powerExC1fMOD = 0.0; 
   else  
       powerExC1fMOD = KF_M * EXMOD * XEXT * pow((abs(XIex) / XEXT), AF); 
 

   
   powerSubsCS_B1S = 2.0 *  1.6021918e-19 * abs(Isub); 
   powerSubsCS_BS  = 2.0 *  1.6021918e-19 * abs(XIsub); 

 

   
 
    twoqIavl  = KAVL*Gem*powerCCS;
   powerCCS_A  = powerCCS + twoqIavl * (3.0 + 2.0 * Gem 
                 - (2.0 + 2.0 * Gem)*(2.0 + 2.0 * Gem)/(1.0 + 2.0 * Gem) ); 
 
   
   I(e, e1)   <+ white_noise(powerREC);           
   I(b, b1)   <+ white_noise(powerRBC);           

   I(b1, b2)  <+ white_noise(powerRBV);           
    
   I(noi, e1) <+ white_noise(twoqIavl);           
   I(c2, e1)  <+ white_noise(powerCCS_A);         
   I(b2, e1)  <+ white_noise(powerFBCS);          
    
   I(b2, e1)  <+ flicker_noise(powerFBC1fB1, 1);  
   I(b2, e1)  <+ flicker_noise(powerFBC1fB2, 1);  
   I(e1, b1)  <+ white_noise(powerEBSCS);         
   I(e1, b1)  <+ flicker_noise(powerEBSC1f, 1);   
   I(b1, c1)  <+ white_noise(powerRBCS);          
   I(b1, c1)  <+ flicker_noise(powerRBC1f, 1);    
   I(b1, c1)  <+ white_noise(powerExCS);          
   I(b1, c1)  <+ flicker_noise(powerExC1f, 1);    
   I(b, c1)   <+ white_noise(powerExCSMOD);       
   I(b, c1)   <+ flicker_noise(powerExC1fMOD, 1); 

   I(b1, s)   <+ white_noise(powerSubsCS_B1S);    
   I(b, s)    <+ white_noise(powerSubsCS_BS);     







 

if (RCBLX > 0.0)
 begin
  if (RCBLI > 0.0)
    begin 
      I(c,  c3)  <+ white_noise(powerRCCxx); 
      I(c3, c4)  <+ white_noise(powerRCCex); 
      I(c4, c1)  <+ white_noise(powerRCCin); 
    end
   else
    begin  
      I(c,  c3)  <+ white_noise(powerRCCxx); 
      I(c3, c1)  <+ white_noise(powerRCCex); 
    end
 end
else
 begin
  if (RCBLI > 0.0)
    begin   
      I(c,  c4)  <+ white_noise(powerRCCxx); 
      I(c4, c1)  <+ white_noise(powerRCCin); 
    end
   else
    begin 
      I(c,  c1)  <+ white_noise(powerRCCxx); 
    end
 end

  
end 

# 51 "admsva/mextram.va"
# 1 "opinfo.inc"

begin 

# 212 "opinfo.inc"
end
# 52 "admsva/mextram.va"
  
end  
endmodule                     

